[ { "title": "Mermaid 入门指南：用代码创建精美图表", "url": "/posts/mermaid-diagram-tutorial/", "categories": "技术分享", "tags": "mermaid, 图表, 文档, 可视化", "date": "2025-09-01 14:30:00 +0900", "snippet": "Mermaid 简介Mermaid 是一个基于 JavaScript 的图表和图形绘制工具，它允许你使用文本和代码来创建各种类型的图表。与传统的图形绘制工具不同，Mermaid 使用类似 Markdown 的语法，让创建和维护图表变得简单高效。 本文中的所有 Mermaid 图表都会在网页中实际渲染，你可以直接看到代码和最终效果的对比！ Mermaid 在 2019 年获得了 JS Op...", "content": "Mermaid 简介Mermaid 是一个基于 JavaScript 的图表和图形绘制工具，它允许你使用文本和代码来创建各种类型的图表。与传统的图形绘制工具不同，Mermaid 使用类似 Markdown 的语法，让创建和维护图表变得简单高效。 本文中的所有 Mermaid 图表都会在网页中实际渲染，你可以直接看到代码和最终效果的对比！ Mermaid 在 2019 年获得了 JS Open Source Awards 的”最激动人心的技术使用”奖项选择 Mermaid 的理由解决文档同步问题传统的图表工具往往会导致”文档腐烂”（Doc-Rot）问题： 图表与代码不同步 更新图表需要专门的软件 版本控制困难 团队协作不便Mermaid 通过代码化的方式完美解决了这些问题。主要优势 简单易学：语法类似 Markdown，学习成本低 版本控制友好：纯文本格式，易于追踪变更 动态渲染：实时更新，支持多种输出格式 广泛支持：GitHub、GitLab、Notion 等平台原生支持Mermaid 支持的图表类型Mermaid 支持多种常用的图表类型： 流程图（Flowchart） - 展示工作流程和决策路径 序列图（Sequence Diagram） - 描述对象间的交互过程 类图（Class Diagram） - 展示类之间的关系 状态图（State Diagram） - 描述系统状态转换 实体关系图（ER Diagram） - 数据库设计图 甘特图（Gantt Chart） - 项目进度管理 饼图（Pie Chart） - 数据占比展示 用户旅程图（User Journey） - 用户体验流程快速开始安装方式你可以通过多种方式使用 Mermaid：CDN 引入&lt;script src=\"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js\"&gt;&lt;/script&gt;NPM 安装npm install mermaidYarn 安装yarn add mermaid基础用法在 HTML 中使用 Mermaid：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"mermaid\"&gt; flowchart TD A[开始] --&gt; B{判断条件} B --&gt;|是| C[执行操作] B --&gt;|否| D[结束] C --&gt; D &lt;/div&gt; &lt;script&gt; mermaid.initialize({startOnLoad: true}); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;流程图入门流程图是最常用的图表类型，让我们从基础语法开始学习。基本语法结构让我们看一个简单的流程图示例，你可以直接对比代码和渲染效果：Mermaid 代码：```mermaidflowchart TD A[矩形节点] --&gt; B{菱形决策} B --&gt;|选择1| C[处理1] B --&gt;|选择2| D[处理2] C --&gt; E((圆形节点)) D --&gt; E```渲染效果：flowchart TD A[矩形节点] --&gt; B{菱形决策} B --&gt;|选择1| C[处理1] B --&gt;|选择2| D[处理2] C --&gt; E((圆形节点)) D --&gt; E节点形状Mermaid 支持多种节点形状，以下是常用的形状对比：代码示例：```mermaidflowchart TD A[方形节点] B(圆角矩形) C([体育场形]) D{菱形} E&gt;旗帜形] F((圆形)) G[\\平行四边形/] H[/梯形\\]```实际效果：flowchart TD A[方形节点] B(圆角矩形) C([体育场形]) D{菱形} E&gt;旗帜形] F((圆形)) G[\\平行四边形/] H[/梯形\\]连接线类型flowchart TD A --&gt; B C --- D E -.-&gt; F G ==&gt; H I --&gt; |带标签| J连接线说明： --&gt; 实线箭头 --- 实线无箭头 -.-&gt; 虚线箭头 ==&gt; 粗实线箭头 --&gt; |标签| 带标签的连接线方向控制flowchart LR A[从左到右] --&gt; B[Left to Right]支持的方向： TD 或 TB：从上到下 BT：从下到上 LR：从左到右 RL：从右到左实际应用示例示例 1：用户登录流程这是一个完整的用户登录流程图，展示了从用户访问到最终跳转的完整过程：完整代码：```mermaidflowchart TD Start([用户访问登录页]) --&gt; Input[输入用户名密码] Input --&gt; Validate{验证信息} Validate --&gt;|有效| CheckAuth{检查权限} Validate --&gt;|无效| Error[显示错误信息] Error --&gt; Input CheckAuth --&gt;|有权限| Success[登录成功] CheckAuth --&gt;|无权限| Forbidden[访问被拒绝] Success --&gt; Dashboard[跳转到仪表板] Forbidden --&gt; Input```渲染结果：flowchart TD Start([用户访问登录页]) --&gt; Input[输入用户名密码] Input --&gt; Validate{验证信息} Validate --&gt;|有效| CheckAuth{检查权限} Validate --&gt;|无效| Error[显示错误信息] Error --&gt; Input CheckAuth --&gt;|有权限| Success[登录成功] CheckAuth --&gt;|无权限| Forbidden[访问被拒绝] Success --&gt; Dashboard[跳转到仪表板] Forbidden --&gt; Input示例 2：软件开发流程flowchart TD A[需求分析] --&gt; B[系统设计] B --&gt; C[编码实现] C --&gt; D[单元测试] D --&gt; E{测试通过?} E --&gt;|否| C E --&gt;|是| F[集成测试] F --&gt; G{集成测试通过?} G --&gt;|否| B G --&gt;|是| H[部署上线] H --&gt; I[运维监控]序列图入门序列图用于展示不同对象或参与者之间的交互过程。基本语法序列图展示了不同参与者之间的时间顺序交互，让我们看一个简单的客户端-服务器交互：序列图代码：```mermaidsequenceDiagram participant A as 客户端 participant B as 服务器 participant C as 数据库 A-&gt;&gt;B: 发送请求 B-&gt;&gt;C: 查询数据 C--&gt;&gt;B: 返回结果 B--&gt;&gt;A: 响应数据```实际效果：sequenceDiagram participant A as 客户端 participant B as 服务器 participant C as 数据库 A-&gt;&gt;B: 发送请求 B-&gt;&gt;C: 查询数据 C--&gt;&gt;B: 返回结果 B--&gt;&gt;A: 响应数据API 调用示例sequenceDiagram participant User as 用户 participant App as 应用 participant API as API服务 participant DB as 数据库 User-&gt;&gt;App: 点击登录 App-&gt;&gt;API: POST /auth/login API-&gt;&gt;DB: 验证用户信息 DB--&gt;&gt;API: 用户数据 API--&gt;&gt;App: JWT Token App--&gt;&gt;User: 登录成功高级技巧1. 子图（Subgraphs）子图功能可以将相关的节点组织在一起，让复杂流程更清晰：子图代码：```mermaidflowchart TD subgraph \"前端处理\" A[用户输入] --&gt; B[表单验证] B --&gt; C[数据格式化] end subgraph \"后端处理\" D[接收请求] --&gt; E[业务逻辑] E --&gt; F[数据存储] end C --&gt; D```渲染效果：flowchart TD subgraph \"前端处理\" A[用户输入] --&gt; B[表单验证] B --&gt; C[数据格式化] end subgraph \"后端处理\" D[接收请求] --&gt; E[业务逻辑] E --&gt; F[数据存储] end C --&gt; D2. 样式自定义通过 classDef 可以为节点定义自定义样式，让图表更加美观：样式定义代码：```mermaidflowchart TD A[开始]:::startStyle --&gt; B[处理]:::processStyle B --&gt; C[结束]:::endStyle classDef startStyle fill:#a7f3d0,stroke:#059669,color:#000 classDef processStyle fill:#fef3c7,stroke:#d97706,color:#000 classDef endStyle fill:#fecaca,stroke:#dc2626,color:#000```样式效果：flowchart TD A[开始]:::startStyle --&gt; B[处理]:::processStyle B --&gt; C[结束]:::endStyle classDef startStyle fill:#a7f3d0,stroke:#059669,color:#000 classDef processStyle fill:#fef3c7,stroke:#d97706,color:#000 classDef endStyle fill:#fecaca,stroke:#dc2626,color:#000最佳实践1. 保持简洁 避免过于复杂的图表 使用有意义的节点标签 合理使用颜色和样式2. 版本控制 将 Mermaid 代码与项目代码一起管理 使用注释说明图表用途 定期更新图表以反映最新状态3. 团队协作 建立统一的图表规范 使用描述性的文件名 在文档中嵌入相关图表平台支持Mermaid 得到了广泛的平台支持： GitHub：Markdown 文件中原生支持 GitLab：内置 Mermaid 渲染 Notion：支持 Mermaid 代码块 VS Code：通过插件支持预览 Obsidian：原生支持 Mermaid 图表工具推荐在线编辑器 Mermaid Live Editor - 官方在线编辑器 Draw.io - 支持 Mermaid 导入编辑器插件 VS Code: Mermaid Preview IntelliJ IDEA: Mermaid Plugin Vim: vim-mermaid总结Mermaid 是一个强大而易用的图表工具，特别适合： 📝 技术文档编写 🔄 流程梳理和设计 👥 团队沟通协作 📊 数据可视化展示通过学习 Mermaid，你可以轻松创建专业的图表，提升文档质量，改善团队协作效率。从简单的流程图开始，逐步探索更多图表类型，你会发现 Mermaid 在日常工作中的巨大价值。 开始你的第一个 Mermaid 图表吧！在 Mermaid Live Editor 中尝试本文的示例代码。" }, { "title": "Slidev：程序员专属的现代化 PPT 制作工具", "url": "/posts/slidev-presentation-tool-guide/", "categories": "技术分享", "tags": "Slidev, 演示文稿, 前端开发, Markdown", "date": "2025-08-24 15:30:00 +0900", "snippet": "为什么程序员需要 Slidev？作为程序员，你是否遇到过这样的痛点： 用传统的 PowerPoint 或 Keynote 制作技术演示，代码格式混乱、语法高亮缺失 需要展示代码片段时，只能截图粘贴，既不美观也无法复制 想要版本控制演示文稿，但二进制格式无法进行有效的 diff 和 merge 团队协作时，不同人使用的软件版本和字体导致排版错乱 想要在演示中加入交互元素或动画，但传统...", "content": "为什么程序员需要 Slidev？作为程序员，你是否遇到过这样的痛点： 用传统的 PowerPoint 或 Keynote 制作技术演示，代码格式混乱、语法高亮缺失 需要展示代码片段时，只能截图粘贴，既不美观也无法复制 想要版本控制演示文稿，但二进制格式无法进行有效的 diff 和 merge 团队协作时，不同人使用的软件版本和字体导致排版错乱 想要在演示中加入交互元素或动画，但传统工具限制很多传统的演示工具虽然功能强大，但对程序员来说并不友好。我们更习惯用代码来描述一切，更喜欢用 Markdown 来写文档，更需要将代码优雅地展示给观众。这时候就轮到我们的主角 Slidev 登场了。 Slidev 完美解决了程序员制作技术演示的痛点，让我们可以用最熟悉的方式创建最专业的演示文稿。什么是 Slidev？Slidev 是一个面向开发者的演示文稿制作工具，全名是 “Presentation Slides for Developers”。翻译成人话就是专门为程序员设计的 PPT 制作工具。核心特性 基于 Markdown：使用熟悉的 Markdown 语法编写内容 代码友好：内置语法高亮，支持多种编程语言 主题丰富：提供多种精美主题，也支持自定义 交互性强：支持动画、图表、数学公式等丰富的交互元素 现代技术栈：基于 Vue 3、Vite 和 UnoCSS 构建 版本控制：纯文本格式，完美支持 Git 导出灵活：可导出为 PDF、PPTX、PNG 或静态网站与传统工具的区别 特性 传统 PPT Slidev 编辑方式 图形界面 代码编辑器 文件格式 二进制 纯文本 Markdown 代码展示 截图/复制粘贴 原生语法高亮 版本控制 困难 完美支持 主题定制 复杂 CSS/Vue 组件 团队协作 容易冲突 Git 协作 导出格式 有限 多种格式 快速开始环境要求在开始之前，确保你的环境满足以下要求： Node.js 版本 ≥ 18.0 包管理器：npm、yarn 或 pnpm（推荐）安装 Slidev推荐使用 pnpm 创建新的 Slidev 项目：pnpm create slidev也可以使用 npm：npm create slidev@latest或者 yarn：yarn create slidev创建第一个演示文稿运行创建命令后，会提示你输入项目名称：? Project name: my-slidev-presentation? Package name: my-slidev-presentation创建完成后，进入项目目录：cd my-slidev-presentation启动开发服务器pnpm dev# 或者npm run dev默认情况下，开发服务器会在 http://localhost:3030 启动。在浏览器中打开这个地址，你就可以看到你的第一个 Slidev 演示文稿了！ 开发服务器支持热重载，修改 Markdown 文件后会自动刷新浏览器。这种实时预览的体验比传统 PPT 工具要流畅很多。核心功能详解Markdown 语法基础Slidev 的核心是 Markdown，但相比普通的 Markdown，它添加了一些演示文稿专用的语法。幻灯片分隔使用三个连字符 --- 来分隔幻灯片：# 第一张幻灯片这是第一张幻灯片的内容。---# 第二张幻灯片这是第二张幻灯片的内容。Front Matter 配置每张幻灯片都可以通过 Front Matter 进行配置：---layout: coverbackground: https://source.unsplash.com/1920x1080/?nature,water---# 欢迎来到我的演示一个很棒的演示文稿---layout: default---# 目录- 第一部分- 第二部分- 第三部分代码高亮和展示这是 Slidev 最强大的功能之一。支持几乎所有主流编程语言的语法高亮：​```typescriptinterface User { id: number name: string email: string}const createUser = (user: User): Promise&lt;User&gt; =&gt; { return fetch('/api/users', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(user) }).then(res =&gt; res.json())}​```代码行高亮可以高亮特定的代码行：​```typescript {2,5-7}interface User { id: number // 这行会被高亮 name: string email: string created_at: Date // 这几行 updated_at: Date // 也会被 deleted_at?: Date // 高亮显示}​```代码行号显示代码行号：​```typescript {lines:true}const fibonacci = (n: number): number =&gt; { if (n &lt;= 1) return n return fibonacci(n - 1) + fibonacci(n - 2)}​```布局系统Slidev 提供了丰富的内置布局，适用于不同的演示场景：基础布局---layout: default---# 默认布局适用于大部分内容展示---layout: center---# 居中布局内容会在页面中央显示---layout: cover---# 封面布局适合作为演示的开头或章节分隔双栏布局---layout: two-cols---# 左侧内容这里是左侧的内容，可以是文字、列表或任何 Markdown 内容。::right::# 右侧内容这里是右侧的内容，通常用于对比或补充说明。图片布局---layout: image-rightimage: https://source.unsplash.com/1920x1080/?coding---# 代码之美左侧是内容，右侧是图片。适合展示概念和视觉效果的结合。主题选择和自定义使用官方主题Slidev 提供了多种精美的主题，在项目根目录的 slides.md 文件顶部配置：---theme: seriph---常用主题推荐： default: 简洁的默认主题 seriph: 优雅的衬线字体主题 apple-basic: 苹果风格的简洁主题 bricks: 现代化的砖块风格主题 carbon: IBM Carbon 设计风格安装第三方主题pnpm add -D slidev-theme-theme-name然后在配置中使用：---theme: theme-name---进阶功能动画效果Slidev 支持丰富的动画效果，让你的演示更生动。点击动画使用 v-click 指令创建点击显示的动画：- &lt;v-click&gt;第一点&lt;/v-click&gt;- &lt;v-click&gt;第二点&lt;/v-click&gt;- &lt;v-click&gt;第三点&lt;/v-click&gt;代码逐行显示​```typescript {1|2-3|4-6|all}interface APIResponse&lt;T&gt; { data: T status: number message: string timestamp: number success: boolean}​```交互组件计数器组件&lt;Counter :count=\"10\" /&gt;图表展示使用 Mermaid 绘制流程图：graph TD A[开始] --&gt; B{是否登录?} B --&gt;|是| C[显示首页] B --&gt;|否| D[跳转登录页] D --&gt; E[输入用户名密码] E --&gt; F{验证成功?} F --&gt;|是| C F --&gt;|否| G[显示错误信息] G --&gt; E数学公式支持 LaTeX 格式的数学公式：行内公式：$x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$块级公式：$$\\begin{aligned}\\nabla \\cdot \\vec{E} &amp;= \\frac{\\rho}{\\epsilon_0} \\\\\\nabla \\cdot \\vec{B} &amp;= 0 \\\\\\nabla \\times \\vec{E} &amp;= -\\frac{\\partial\\vec{B}}{\\partial t} \\\\\\nabla \\times \\vec{B} &amp;= \\mu_0\\vec{J} + \\mu_0\\epsilon_0\\frac{\\partial\\vec{E}}{\\partial t}\\end{aligned}$$自定义样式局部样式在幻灯片中添加样式：---layout: center---# 标题&lt;style&gt;h1 { background-color: #2B90B6; background-image: linear-gradient(45deg, #4EC5D4 10%, #146b8c 20%); background-size: 100%; -webkit-background-clip: text; -moz-background-clip: text; -webkit-text-fill-color: transparent; -moz-text-fill-color: transparent;}&lt;/style&gt;全局样式在项目根目录创建 style.css 文件：.slidev-layout { font-family: 'JetBrains Mono', monospace;}.code-block { border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);}实用工作流程演示文稿制作流程1. 规划结构在开始编写之前，先规划好演示的整体结构：---theme: seriphbackground: https://source.unsplash.com/1920x1080/?codetitle: 我的技术分享---# 目录规划1. 问题背景2. 技术选型3. 实现方案4. 效果展示5. 总结与展望2. 内容编写按照规划逐步编写内容：---layout: section---# 问题背景---# 面临的挑战- **性能问题**：现有方案处理大数据时延迟较高- **维护成本**：代码复杂度高，难以维护- **扩展性差**：难以适应业务快速变化&lt;v-click&gt;## 为什么需要重构？&lt;/v-click&gt;3. 视觉优化添加图片、图表和动画：---layout: image-rightimage: /images/architecture-diagram.png---# 新的架构设计- 微服务架构- 事件驱动- 容器化部署&lt;v-click&gt;性能提升 **300%**！&lt;/v-click&gt;导出和分享导出 PDFpnpm run export这会在 dist 目录生成 PDF 文件。导出为静态网站pnpm run build生成的静态文件可以部署到任何静态托管服务。自定义导出选项在 package.json 中添加导出脚本：{ \"scripts\": { \"export:pdf\": \"slidev export --format pdf\", \"export:png\": \"slidev export --format png\", \"export:pptx\": \"slidev export --format pptx\", \"build:gh-pages\": \"slidev build --base /my-presentation/\" }}版本控制集成由于 Slidev 使用纯文本格式，可以完美地与 Git 集成：# 创建新分支进行演示修改git checkout -b update-presentation# 提交更改git add slides.mdgit commit -m \"feat: add new section about performance optimization\"# 合并到主分支git checkout maingit merge update-presentation团队协作最佳实践1. 目录结构组织my-presentation/├── slides.md # 主演示文件├── pages/ # 分页内容│ ├── 01-introduction.md│ ├── 02-background.md│ └── 03-solution.md├── components/ # 自定义组件├── public/ # 静态资源│ └── images/├── styles/ # 样式文件└── package.json2. 分工协作---# slides.md - 主文件，由项目负责人维护src: ./pages/01-introduction.md------# 各部分由不同成员负责src: ./pages/02-background.md------src: ./pages/03-solution.md---最佳实践内容组织建议1. 一屏一概念每张幻灯片只讲一个核心概念，避免信息过载：---layout: center---# 单一职责原则一个类应该只有一个引起它变化的原因---layout: default---# 举个例子​```typescript// ❌ 违反单一职责原则class User { save() { /* 保存到数据库 */ } sendEmail() { /* 发送邮件 */ } generateReport() { /* 生成报表 */ }}​```&lt;v-click&gt;​```typescript// ✅ 遵循单一职责原则class User { constructor(public data: UserData) {}}class UserRepository { save(user: User) { /* 保存到数据库 */ }}class EmailService { sendEmail(user: User) { /* 发送邮件 */ }}​```&lt;/v-click&gt;2. 逐步展示复杂概念使用动画逐步展示复杂的概念：---layout: default---# React 组件生命周期&lt;v-clicks&gt;1. **挂载阶段 (Mounting)** - constructor() - componentDidMount()2. **更新阶段 (Updating)** - componentDidUpdate() - getSnapshotBeforeUpdate()3. **卸载阶段 (Unmounting)** - componentWillUnmount()&lt;/v-clicks&gt;视觉设计原则1. 保持一致的样式定义统一的代码块样式：&lt;style&gt;.code-container { background: #1e1e1e; border-radius: 8px; padding: 20px; margin: 20px 0;}.highlight { background: #ffd700; padding: 2px 4px; border-radius: 4px;}&lt;/style&gt;2. 合理使用颜色使用颜色来区分不同类型的信息：- &lt;span style=\"color: #4CAF50\"&gt;✅ 推荐做法&lt;/span&gt;- &lt;span style=\"color: #FF5722\"&gt;❌ 不推荐做法&lt;/span&gt;- &lt;span style=\"color: #2196F3\"&gt;💡 提示信息&lt;/span&gt;性能优化技巧1. 图片优化---layout: image-rightimage: /images/optimized-chart.webp---# 性能监控图表使用 WebP 格式可以减少 25% 的文件大小2. 懒加载重内容对于包含大量图片或复杂组件的幻灯片，使用懒加载：&lt;template&gt; &lt;div v-if=\"$slidev.nav.clicks &gt; 0\"&gt; &lt;HeavyComponent /&gt; &lt;/div&gt;&lt;/template&gt;演示技巧1. 使用快捷键在演示过程中掌握这些快捷键： 快捷键 功能 Space / → 下一步 ← 上一步 f 全屏模式 o 幻灯片概览 d 深色模式切换 g 跳转到指定页面 2. 演讲者备注添加只有演讲者能看到的备注：---layout: center---# 重要概念这是一个重要的概念&lt;!--这里是演讲者备注，观众看不到。提醒：记得举例说明这个概念的实际应用。--&gt;3. 录制和分享Slidev 支持录制功能：pnpm run export --with-clicks --format pdf常见问题安装问题Q: Node.js 版本过低怎么办？A: Slidev 需要 Node.js 18+。推荐使用 nvm 管理 Node.js 版本：# 安装最新的 LTS 版本nvm install --ltsnvm use --ltsQ: pnpm 命令不存在？A: 安装 pnpm：npm install -g pnpm使用技巧Q: 如何在代码中显示文件路径？A: 使用文件名标注：​```typescript:components/UserCard.vue&lt;template&gt; &lt;div class=\"user-card\"&gt; &lt;/div&gt;&lt;/template&gt;​```Q: 如何添加背景音乐？A: 在幻灯片中嵌入音频：---layout: cover---# 欢迎&lt;audio controls autoplay loop&gt; &lt;source src=\"/audio/background.mp3\" type=\"audio/mpeg\"&gt;&lt;/audio&gt;Q: 如何制作代码对比？A: 使用双栏布局：---layout: two-cols---# 重构前​```javascriptfunction getUserInfo(id) { var user = getUser(id) var profile = getProfile(id) var settings = getSettings(id) return { user: user, profile: profile, settings: settings }}​```::right::# 重构后​```javascriptconst getUserInfo = async (id) =&gt; { const [user, profile, settings] = await Promise.all([ getUser(id), getProfile(id), getSettings(id) ]) return { user, profile, settings }}​```故障排除Q: 开发服务器启动失败？A: 检查端口是否被占用：# 使用不同端口启动pnpm dev --port 3031Q: 导出 PDF 时样式错误？A: 确保安装了必要的依赖：pnpm add -D playwright-chromiumQ: 主题不生效？A: 检查主题是否正确安装：pnpm add -D slidev-theme-seriph然后在 slides.md 中配置：---theme: seriph--- 如果遇到其他问题，可以查看 Slidev 官方文档 或者在 GitHub Issues 中搜索解决方案。总结Slidev 作为一个专为开发者设计的演示工具，完美解决了程序员在制作技术演示时遇到的各种痛点。它将我们熟悉的 Markdown 语法与现代前端技术相结合，让我们可以用代码的方式来创建演示文稿。核心优势回顾 开发者友好：Markdown + 代码编辑器的组合 功能强大：丰富的布局、主题和交互功能 版本控制：完美支持 Git，便于团队协作 现代化：基于最新的前端技术栈 灵活导出：支持多种格式的导出和分享适用场景 技术分享：内部技术分享、开源项目介绍 会议演讲：技术会议、行业峰会演讲 教学培训：编程课程、技术培训 产品展示：向技术团队展示产品特性 文档演示：将技术文档转化为可视化演示下一步建议 动手实践：创建你的第一个 Slidev 演示文稿 探索主题：尝试不同的主题找到最适合的风格 学习进阶功能：掌握动画、交互组件等高级特性 建立模板：为团队创建统一的演示模板 分享经验：与同事分享 Slidev 的使用心得记住，好的演示不仅仅是工具的使用，更重要的是内容的组织和表达。Slidev 给了我们强大的工具，如何用好它来创造价值才是关键。开始你的 Slidev 之旅吧，让技术演示变得更加专业和高效！&gt; &lt;参考资源 Slidev 官方网站 Slidev GitHub 仓库 Slidev 官方文档 主题和插件市场 Slidev Discord 社区 Vue.js 官方文档 Markdown 语法指南" }, { "title": "Claude Code 从入门到实践", "url": "/posts/claude-code-from-beginner-to-practice/", "categories": "技术分享", "tags": "Claude, AI, CLI, DevTools", "date": "2025-08-02 10:30:00 +0900", "snippet": "什么是 Claude Code？Claude Code 是 Anthropic 开发的命令行工具，让开发者能够在终端中直接与 Claude AI 协作进行编程任务。它不仅是一个聊天工具，更是一个强大的编程助手，能够： 读取和编辑代码文件 执行命令行操作 管理 Git 仓库 安装和配置开发环境 通过 MCP (Model Context Protocol) 扩展功能 Claude ...", "content": "什么是 Claude Code？Claude Code 是 Anthropic 开发的命令行工具，让开发者能够在终端中直接与 Claude AI 协作进行编程任务。它不仅是一个聊天工具，更是一个强大的编程助手，能够： 读取和编辑代码文件 执行命令行操作 管理 Git 仓库 安装和配置开发环境 通过 MCP (Model Context Protocol) 扩展功能 Claude Code 的核心价值在于将 AI 助手无缝集成到开发工作流程中，让编程变得更高效。快速开始安装推荐使用 npm 安装：npm install -g @anthropic-ai/claude-code也可以使用官方安装脚本：curl -fsSL https://install.anthropic.com | sh更新版本保持 Claude Code 为最新版本以获得最佳体验：npm update -g @anthropic-ai/claude-code 建议定期检查并更新版本，新版本通常包含性能改进和新功能。首次使用claude首次运行时会提示进行身份验证，按照指示完成配置即可。更多安装和配置详情：Claude Code 官方文档项目初始化在新项目中，可以使用 /init 命令进行智能初始化：/init该命令会： 自动分析当前代码仓库的结构和技术栈 识别项目的开发工作流程和常用命令 自动生成 CLAUDE.md 配置文件 为项目定制 Claude 的行为和响应方式 使用 /init 可以让 Claude 更好地理解你的项目，提供更精准的帮助。核心功能交互模式和快捷键Claude Code 提供多种交互模式来优化工作流程：自动接受模式 快捷键：Shift + Tab 功能：自动接受 Claude 的建议和操作 适用场景：信任 Claude 的操作时使用计划模式 (Plan Mode) 快捷键：Shift + Tab (在自动模式基础上再按一次) 功能：Claude 会先制定计划，等待用户确认后再执行 适用场景：复杂任务或需要审查的操作其他快捷键 Esc：中断当前操作 Ctrl + C：退出 Claude Code上下文管理Claude Code 支持多种方式为 AI 提供上下文信息：局部上下文 选中文本：在编辑器中选中代码后直接询问 复制粘贴： 少量文本：直接粘贴 大量文本：会显示缩略信息 截图粘贴：Ctrl + V 粘贴截图 文件引用：@filename 引用特定文件 文件夹搜索：@/ 搜索整个文件夹 URL 分析：直接输入网址让 Claude 分析网页内容整体上下文 claude -c：继续上次的会话 (continue) claude -r：恢复历史会话 (resume) /clear：清除当前会话，开始新对话 /compact &lt;指令&gt;：手动压缩会话历史记忆管理 (Claude Memories)Claude Code 支持持久化记忆功能：# 添加规则和偏好\\# 项目使用 TypeScript 严格模式\\# 代码风格遵循 Prettier 配置\\# 测试框架使用 Jest这些记忆会自动保存到文件中，在后续会话中生效。MCP (Model Context Protocol) 扩展MCP 是 Claude Code 的扩展系统，允许集成外部工具和服务。安装常用 MCP 服务Context7 - 获取最新文档和代码示例：claude mcp add --transport http context7 https://mcp.context7.com/mcpDeepWiki - GitHub 仓库文档查询：claude mcp add -s user -t http deepwiki https://mcp.deepwiki.com/mcpPlaywright - 浏览器自动化和网页操作：claude mcp add playwright npx @playwright/mcp@latestMCP 管理命令claude mcp list # 列出已安装的 MCP 服务claude mcp remove &lt;name&gt; # 移除 MCP 服务最佳实践和工作流程1. 探索-计划-编码-提交工作流探索阶段 先阅读相关文件，不急于编写代码 使用 “think” 模式触发更深入的分析 理解代码库结构和约定计划阶段 使用计划模式制定详细方案 确认方案的合理性 分解复杂任务为小步骤编码阶段 逐步实现功能 遵循项目代码风格 及时测试验证提交阶段 编写清晰的提交信息 确保代码质量2. 测试驱动开发 (TDD)# 示例工作流claude \"帮我为用户认证模块编写测试\"# Claude 编写测试用例claude \"运行测试确认失败\"# 实现功能代码claude \"再次运行测试确认通过\"3. 视觉迭代方法特别适用于前端开发： 提供设计稿或截图 Claude 实现初版 截图对比效果 迭代改进 2-3 次4. 权限管理使用 /permissions 命令管理 Claude 的操作权限：/permissions # 查看当前权限/permissions allow git # 允许 Git 操作/permissions deny file # 禁止文件编辑5. 多实例协作对于大型项目，可以： 使用多个 Claude 实例并行处理任务 利用 Git worktrees 进行独立开发 通过自定义斜杠命令简化重复工作流DevContainer 集成在 devcontainer.json 中添加 Claude Code：{ \"features\": { \"ghcr.io/devcontainers/features/node:1\": {}, \"ghcr.io/anthropics/devcontainer-features/claude-code:1\": {} }}如果已有 Node.js 环境，只需添加：{ \"features\": { \"ghcr.io/anthropics/devcontainer-features/claude-code:1\": {} }}参考：DevContainer Features 文档无头模式 (Headless Mode)Claude Code 支持在脚本中使用：# 流式输出 JSON 格式claude -p \"分析这个错误日志\" --output-format stream-json# 批处理模式claude -p \"重构这个函数\" --auto-accept适用于 CI/CD 管道和自动化脚本。CLAUDE.md 配置文件为项目创建 CLAUDE.md 文件来： 记录常用命令和脚本 定义代码风格指南 说明项目结构和约定 提供开发环境设置说明 记录已知问题和注意事项示例：# 项目配置## 开发命令npm run dev # 启动开发服务器npm run test # 运行测试npm run build # 构建生产版本## 代码风格- 使用 TypeScript 严格模式- 遵循 ESLint 和 Prettier 配置- 组件使用 PascalCase 命名## 注意事项- API 端点需要认证- 数据库连接使用环境变量常见问题和解决方案安装问题 确保 Node.js 版本 ≥ 18 检查网络连接和防火墙设置 使用 claude --version 验证安装性能优化 定期使用 /clear 清理会话 合理使用 /compact 压缩历史 避免上传过大的文件或截图权限问题 检查文件系统权限 确认 Git 仓库状态 使用 /permissions 调整权限设置进阶技巧自定义斜杠命令创建项目特定的快捷命令：# 在 CLAUDE.md 中定义/deploy # 部署到生产环境/test-all # 运行完整测试套件/lint-fix # 修复代码风格问题Git 集成最佳实践# 让 Claude 帮助生成提交信息claude \"分析这些更改并生成合适的提交信息\"# 代码审查claude \"审查这个 Pull Request 的代码质量\"# 分支管理claude \"帮我创建功能分支并设置上游\"调试工作流# 错误分析claude \"这个错误是什么原因？\" @error.log# 性能分析claude \"分析这个函数的时间复杂度\" @utils.js# 代码重构claude \"重构这个组件提高可读性\" @component.jsx参考资源 Claude Code 官方文档 Claude Code 最佳实践 MCP 协议规范 DevContainer 集成指南" }, { "title": "AWS 基础网络服务实战（一）：使用 Terraform 创建 VPC", "url": "/posts/terraform-vpc/", "categories": "技术分享", "tags": "terraform, aws, vpc, iaas", "date": "2025-06-06 10:00:00 +0900", "snippet": "VPC 基础与应用场景在 AWS 上部署服务，第一步就是构建属于自己的网络环境。VPC（Virtual Private Cloud）让你可以像搭积木一样，定制自己的云上网络结构，隔离、管理和保护你的资源。 本文将介绍如何用 Terraform 快速搭建一个自定义 VPC，并给出完整代码和最佳实践。VPC 的核心概念 CIDR 块：定义网络的 IP 范围，比如 10.0.0.0/16 子...", "content": "VPC 基础与应用场景在 AWS 上部署服务，第一步就是构建属于自己的网络环境。VPC（Virtual Private Cloud）让你可以像搭积木一样，定制自己的云上网络结构，隔离、管理和保护你的资源。 本文将介绍如何用 Terraform 快速搭建一个自定义 VPC，并给出完整代码和最佳实践。VPC 的核心概念 CIDR 块：定义网络的 IP 范围，比如 10.0.0.0/16 子网（Subnet）：VPC 内的子网络，通常分为公有和私有 路由表（Route Table）：决定流量如何在子网和外部之间流动 Internet Gateway：让 VPC 内的资源可以访问互联网 NAT Gateway：让私有子网的资源可以访问互联网，但外部无法主动访问它们一个典型的 VPC 结构，包含公有和私有子网用 Terraform 创建 VPC1. 初始化 Terraform 项目在开始之前，建议新建一个目录用于本次实验，并初始化 Terraform：mkdir terraform-vpc-demo &amp;&amp; cd terraform-vpc-demoterraform init2. 资源规划与配置说明在 AWS 网络基础设施中，通常需要以下核心资源： VPC：定义整个网络的 IP 范围，是所有资源的容器。 子网（Subnet）：VPC 内的子网络，分为公有子网（可直连互联网）和私有子网（仅内网访问）。 Internet Gateway：为公有子网提供互联网访问能力。 NAT Gateway：为私有子网提供出网能力。 路由表（Route Table）：控制子网的流量走向。下面将逐步用 Terraform 创建这些资源。创建 VPCmain.tf 示例：provider \"aws\" { region = \"ap-northeast-1\"}resource \"aws_vpc\" \"main\" { cidr_block = \"10.0.0.0/16\" # 定义 VPC 的 IP 范围 enable_dns_support = true # 启用 DNS 解析 enable_dns_hostnames = true # 启用 DNS 主机名 tags = { Name = \"demo-vpc\" }} cidr_block：VPC 的 IP 地址范围。 enable_dns_support 和 enable_dns_hostnames：建议开启，便于后续资源通过域名互通。创建公有子网、私有子网与 Internet Gateway在实际生产环境中，通常会将子网分为公有和私有： 公有子网：可直接访问互联网，适合部署 Web 服务器等需要公网访问的资源。 私有子网：无法直接访问互联网，适合部署数据库、应用服务器等内网资源。区别说明： 公有子网通过 Internet Gateway 访问互联网。 私有子网通常通过 NAT Gateway 访问互联网，外部无法主动访问。# 公有子网resource \"aws_subnet\" \"public\" { vpc_id = aws_vpc.main.id cidr_block = \"10.0.1.0/24\" # 公有子网 IP 段 availability_zone = \"ap-northeast-1a\" map_public_ip_on_launch = true # 自动分配公网 IP tags = { Name = \"public-subnet\" }}# 私有子网resource \"aws_subnet\" \"private\" { vpc_id = aws_vpc.main.id cidr_block = \"10.0.2.0/24\" # 私有子网 IP 段 availability_zone = \"ap-northeast-1a\" tags = { Name = \"private-subnet\" }}# Internet Gatewayresource \"aws_internet_gateway\" \"gw\" { vpc_id = aws_vpc.main.id tags = { Name = \"demo-igw\" }}# 公有路由表resource \"aws_route_table\" \"public\" { vpc_id = aws_vpc.main.id route { cidr_block = \"0.0.0.0/0\" gateway_id = aws_internet_gateway.gw.id } tags = { Name = \"public-rt\" }}# 公有子网关联路由表resource \"aws_route_table_association\" \"public\" { subnet_id = aws_subnet.public.id route_table_id = aws_route_table.public.id} aws_subnet.public：公有子网，自动分配公网 IP。 aws_subnet.private：私有子网，不分配公网 IP。 aws_internet_gateway.gw：为 VPC 提供互联网访问。 aws_route_table.public：公有路由表，所有流量通过 IGW 出网。 aws_route_table_association.public：将公有子网与公有路由表关联。 补充：如需让私有子网访问互联网，还需创建 NAT Gateway 和私有路由表，后续章节会详细介绍。3. 应用配置terraform planterraform apply几分钟后，你就拥有了一个带有公有和私有子网的 VPC！最佳实践 合理划分 CIDR，避免与公司内网冲突 开启 DNS 支持，方便资源间通过域名通信 资源命名规范，便于后续维护 使用变量和模块，提升可复用性（后续章节会详细介绍）参考资料 Terraform AWS Provider Docs AWS VPC 官方文档 VPC 设计最佳实践" }, { "title": "新 Mac 环境配置指南", "url": "/posts/setting-up-new-mac/", "categories": "", "tags": "Mac", "date": "2024-03-17 10:30:00 +0900", "snippet": "1. 安装 Homebrew这一步会自动安装 xcode-select，包含了常用的开发工具。/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"2. 安装常用应用以下按需安装。其它软件可在 Homebrew 查找。brew install --cask ...", "content": "1. 安装 Homebrew这一步会自动安装 xcode-select，包含了常用的开发工具。/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"2. 安装常用应用以下按需安装。其它软件可在 Homebrew 查找。brew install --cask iterm2brew install --cask google-chromebrew install --cask visual-studio-codebrew install --cask jetbrains-toolboxbrew install --cask rectanglebrew install --cask plexbrew install --cask iinabrew install --cask qqbrew install --cask wechatbrew install --cask downiebrew install --cask topnotchbrew install --cask snipastebrew install --cask dockerbrew install --cask githubbrew install --cask captinbrew install --cask notionbrew install --cask chatgptbrew install --cask cursorbrew install --cask slackbrew install --cask claude3. 安装 CLI 命令按需安装。brew install ghbrew install nvmbrew install tmuxbrew install pecobrew install mysql4. 安装 Oh My ZshmacOS Catalina 之后默认使用 zsh，可直接安装 Oh My Zsh。sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"配置 Dotfiles配置文件仓库：https://github.com/Amabel/dotfiles用以下命令直接将仓库中的文件拷贝到 Home 目录下curl --fail --silent --show-error --location https://codeload.github.com/Amabel/dotfiles/tar.gz/master | tar -x -C ~ --strip-components=15. 安装输入法谷歌日语输入法：https://www.google.co.jp/ime/搜狗输入法：https://pinyin.sogou.com/mac/6. vscode 扩展（或者通过 vscode 同步功能自动安装）code --install-extension eamodio.gitlenscode --install-extension yzhang.markdown-all-in-onecode --install-extension github.vscode-pull-request-githubcode --install-extension ms-vscode-remote.vscode-remote-extensionpackcode --install-extension vue.volarcode --install-extension esbenp.prettier-vscodecode --install-extension vscode-icons-team.vscode-iconscode --install-extension streetsidesoftware.code-spell-checkercode --install-extension oderwat.indent-rainbowcode --install-extension mechatroner.rainbow-csvcode --install-extension mkxml.vscode-filesizecode --install-extension shardulm94.trailing-spacescode --install-extension wakatime.vscode-wakatimecode --install-extension github.vscode-github-actionscode --install-extension formulahendry.auto-rename-tagcode --install-extension vincaslt.highlight-matching-tagcode --install-extension bradlc.vscode-tailwindcsscode --install-extension visualstudioexptteam.vscodeintellicodecode --install-extension codeium.codeiumcode --install-extension amazonwebservices.aws-toolkit-vscode7. 从 App Store 下载软件 iTab iBar iRightMouse Better Menubar " }, { "title": "一些关于 GitHub 设定的小技巧", "url": "/posts/tips-of-github-settings/", "categories": "技术分享", "tags": "github, git", "date": "2023-10-15 10:30:00 +0900", "snippet": "GitHubコマテク集这篇文章整理了一些关于 GitHub 的设定小技巧，可以用于团队开发中。", "content": "GitHubコマテク集这篇文章整理了一些关于 GitHub 的设定小技巧，可以用于团队开发中。" }, { "title": "在 Nginx 的容器中开启 debug 模式", "url": "/posts/nginx-enable-debug-mode/", "categories": "技术分享", "tags": "nginx, debug", "date": "2023-06-25 10:30:00 +0900", "snippet": "在使用 Nginx 的容器时候，需要开启 debug 日志来进行错误排查。步骤 1： 使用 nginx-debug 来启动容器$ docker run --name my-nginx -v /host/path/nginx.conf:/etc/nginx/nginx.conf:ro -d nginx nginx-debug -g 'daemon off;'或者当使用 docker compo...", "content": "在使用 Nginx 的容器时候，需要开启 debug 日志来进行错误排查。步骤 1： 使用 nginx-debug 来启动容器$ docker run --name my-nginx -v /host/path/nginx.conf:/etc/nginx/nginx.conf:ro -d nginx nginx-debug -g 'daemon off;'或者当使用 docker compose 时:web: image: nginx volumes: - ./nginx.conf:/etc/nginx/nginx.conf:ro command: [nginx-debug, '-g', 'daemon off;']步骤 2： 在配置文件中启用 debug 日志server { error_log logs/error.log debug;}参考资料 Docker - nginx Configuring Logging | NGINX Documentation" }, { "title": "使用 Nginx 的 X-Accel 功能从 S3 下载文件", "url": "/posts/nginx-x-accel-redirect/", "categories": "技术分享", "tags": "nginx, x-accel", "date": "2023-04-01 10:30:00 +0900", "snippet": "具体需求之前接到一个需求：前端请求下载文件后，先在后端进行权限验证，之后生成 S3 的预签名 URL，再通过 Nginx 进行文件的下载。流程图：sequenceDiagram autonumber participant browser as Browser participant nginx as Nginx participant backend as Back...", "content": "具体需求之前接到一个需求：前端请求下载文件后，先在后端进行权限验证，之后生成 S3 的预签名 URL，再通过 Nginx 进行文件的下载。流程图：sequenceDiagram autonumber participant browser as Browser participant nginx as Nginx participant backend as Backend participant s3 as AWS S3 browser -&gt;&gt; nginx: 请求下载文件： GET /download?filename=image.jpg activate nginx nginx -&gt;&gt; backend: 获取 S3 预签名 URL： GET /fileUrl?filename=image.jpg activate backend backend -&gt;&gt; backend: 验证用户身份和权限 backend -&gt;&gt; backend: 生成预签名 URL backend --&gt;&gt; nginx: 要求重定向到 S3 预签名 URL (X-Accel-Redirect) deactivate backend nginx -&gt;&gt; s3: 通过预签名 URL 请求文件内容 activate s3 s3 --&gt;&gt; nginx: 返回文件内容 deactivate s3 nginx --&gt;&gt; browser: 返回文件内容 deactivate nginx其中主要的步骤1. 前端请求获取文件前端需要展示或者下载文件时，向 Nginx发送获取文件的请求。2. Nginx 向后端请求 S3 预签名 URL由于 S3 的 Bucket 是加密的，并且 Nginx 没有权限直接访问 S3，所以要向后端请求预签名 URL 来获得访问权限。3. 后端验证用户身份权限根据实际业务需求后端可以通过请求内容（session 或 token）来验证用户的权限。4. 生成预签名 URL后端使用 S3 的访问权限来生成预签名 URL，使得任何拥有 URL 的人都可以访问文件对象。5. 要求 Nginx 重定向到 S3后端使用 Nginx 的 X-Accel 功能，通过在 Response 的 Header 中设置 X-Accel-Redirect，来让 Nginx 自动进行跳转。// 设置返回的 headersresponse.headers['X-Accel-Redirect'] = '/s3-redirect/filename/https://example-bucket.s3.amazonaws.com/example-object?key=value&amp;Expires=1672531200&amp;Signature=xxxxxx&amp;x-amz-security-token=xxxxxx&amp;x-amz-algorithm=AWS4-HMAC-SHA256' 关于 Nginx 的 X-Accel 功能，可以参考 官方文档 。6. Nginx 根据后端返回的头部进行跳转Nginx 在接收到返回之后，如果 headers 中有设置 X-Accel-Redirect 的值，那么会自动跳转到该 location。配置文件例子如下：server { # ... # 前端访问 /files?filename=xxx 时，将请求发送给后端 location /files { # 如果使用 k8s 则需要添加本地的 DNS resolver resolver kube-dns.kube-system.svc.cluster.local; # 跳转到后端地址，默认不会传递参数，所以要手动加上参数 proxy_pass http://backend.namespace.svc.cluster.local/api/file-download$is_args$args; } # 在步骤 5 中已经将 `X-Accel-Redirect` 设置为以 `s3-redirect` 开头，因此会匹配下面的 location # 并用正则表达式取出文件名和 S3 的URL，其中 $1 为文件名，$2 为跳转地址 location ~ ^/s3-redirect/(.*?)/(.*) { # 只允许内部跳转，前端无法通过输入 URL 直接访问，增强了安全性 internal; # 由于要跳转到 S3 的地址，需要加上外部 DNS，这里用谷歌的 DNS resolver 8.8.8.8; # 跳转到 S3 并下载文件，同样记得带上参数 proxy_pass $2$is_args$args; # 添加头部，若为图片等可以内联展示的文件则直接展示，如果不能（PDF 等文件）则下载文件并保存为指定的文件名 add_header Content-Disposition 'inline; filename=\"$1\"'; }}上面的例子是真实案例，可以根据实际情况简化一些设置，比如不需要 k8s 的 DNS resolver 设置，以及不需要文件下载的相关设置。 关于 Nginx 的 内置变量，可以参考 官方文档 。 关于 Nginx 默认不会传递查询参数，可以看这篇回答。总结当时踩的几个坑 k8s 通过 service 名来访问其他 service 的时候需要加上本地的 DNS resolver proxy_pass 默认不会传递参数，需要用内置变量手动传递 Nginx 的路径匹配规则，正则匹配，贪婪和非贪婪 internal 关键字 跳转到外部时需要加上外部的 DNS resolver 手动添加 headers 来控制文件的下载参考资料 S3 の非公開ファイルを nginx X-Accel-Redirect と Rails の認証セッションを使って限定公開する | Basicinc Enjoy Hacking! Nginx proxy Amazon S3 resources - Stack Overflow" }, { "title": "新的工作地点", "url": "/posts/new-work-place/", "categories": "日常", "tags": "", "date": "2023-01-04 10:30:00 +0900", "snippet": "新的工作地点。可以看到东京塔和富士山", "content": "新的工作地点。可以看到东京塔和富士山" }, { "title": "一些 JavaScript 的库的整理", "url": "/posts/awesome-js-libraries/", "categories": "技术分享", "tags": "library, awesome", "date": "2022-12-12 10:30:00 +0900", "snippet": "分享一些开源 JavaScript 库，以及它们的维护情况。JavaScript Repository Name Keywords Last Updated Note saadeghi/daisyui ui,component 2025/09/28 基于 Tailwind 的 ...", "content": "分享一些开源 JavaScript 库，以及它们的维护情况。JavaScript Repository Name Keywords Last Updated Note saadeghi/daisyui ui,component 2025/09/28 基于 Tailwind 的 UI 组件库 atomiks/tippyjs ui,tooltip,dropdown 2024/05/27 提示标签 floating-ui/floating-ui ui,anchor 2025/09/22 实现各种组件的定位、漂浮效果 notiflix/Notiflix ui,alert,notification 2025/01/04 通知，加载，提示框等方案 fengyuanchen/viewerjs ui,image,viewer 2025/01/05 图片查看，画廊 fengyuanchen/cropperjs ui,image 2025/07/25 图像裁剪 wagerfield/parallax ui,image,animation 2024/04/06 使用陀螺仪或鼠标生成视差特效 mattboldt/typed.js ui,typing,animation 2025/02/07 打字机特效 nolimits4web/swiper ui,slide 2025/09/24 幻灯片效果 kenwheeler/slick ui,slide,carousel 2025/09/13 幻灯片效果 slidevjs/slidev ui,slide 2025/09/25 幻灯片效果 sindresorhus/screenfull ui,full screen 2022/07/08 全屏显示 alvarotrigo/fullPage.js ui,swipe,page 2025/06/28 整页效果 hakimel/reveal.js ui,swipe,mobile 2025/09/16 移动端的页面滑动方案 usablica/intro.js ui,onboarding 2025/09/21 界面操作引导 benhowdle89/grade ui,image,color 2022/08/02 根据图片颜色自动生成背景色 highlightjs/highlight.js ui,text,markdown,code 2025/09/15 代码高亮 VincentGarreau/particles.js ui,animation,background 2024/03/28 粒子背景特效 mrdoob/three.js ui,animation,3d 2025/09/27 3D 特效引擎 juliangarnier/anime ui,animation 2025/09/22 动画特效引擎 showdownjs/showdown ui,markdown 2024/08/20 Markdown 转换工具 markedjs/marked ui,markdown 2025/09/22 Markdown 转换工具 codex-team/editor.js ui,editor,text 2025/09/15 功能强大的编辑器 niklasvh/html2canvas ui,html,canvas 2024/07/18 将 HTML 转换为 Canvas。用于保存或展示 ustbhuangyi/better-scroll ui,scroll 2024/06/14 移动端的页面滑动增强 d3/d3 ui,data,chart 2025/07/27 根据数据生成图表 chartjs/Chart.js ui,data,chart 2025/09/19 图表生成 apache/echarts ui,data,chart 2025/09/26 图表生成 mozilla/pdf.js ui,pdf reader 2025/09/27 PDF 阅读器 zenorocha/clipboard.js clipboard 2025/08/06 剪贴板 js-cookie/js-cookie cookie 2025/08/24 Cookie 的使用 eligrey/FileSaver.js file,save 2023/03/01 保存为本地文件 adamwdraper/Numeral-js input,number,currency 2024/04/24 精确的数字计算 scurker/currency.js input,number,currency 2025/09/27 货币运算 hapijs/joi input,data,validation 2025/08/20 数据验证，输入验证 ten1seven/what-input input,detector 2025/02/17 用户输入检测 ccampbell/mousetrap input,keyboard 2023/03/15 键盘快捷键方案 uNmAnNeR/imaskjs format,text,number 2024/10/11 自定义格式，自动格式化输入文本 nosir/cleave.js format,text,number 2023/11/25 自定义格式，自动格式化输入文本 moment/moment format,date,time 2024/08/14 格式化时间、日期 moment/luxon format,date,time 2025/09/27 格式化时间、日期。轻量 iamkun/dayjs format,date,time 2025/09/26 格式化时间、日期。更轻量 date-fns/date-fns format,date,time 2025/09/08 格式化时间、日期 vercel/ms time,converter 2025/08/27 将各种时间转换为毫秒 blakeembrey/change-case converter,case 2025/06/17 各种大小写格式的转换 reactivex/rxjs rx,reactive 2025/02/23 响应式编程解决方案 faisalman/ua-parser-js user agent,browser,environment 2025/09/27 用户 UA 检测 axios/axios http,request,network 2025/09/27 HTTP 请求 softonic/axios-retry http,request,axios 2025/06/17 axios 的重试插件 i18next/i18next i18n,translate,language 2025/09/05 国际化 justadudewhohacks/face-api.js face detection,computer vision 2024/01/24 面部识别 mpetroff/pannellum image,panorama,3d 2025/06/28 根据图片生成全景模式 DIYgod/DPlayer video player,media 2025/05/16 视频播放器。可以实现弹幕功能 videojs/video.js video player,media 2025/08/01 视频播放器 sampotts/plyr video player,media 2025/08/27 视频播放器 BMSVieira/moovie.js video player,media 2025/01/03 又一个视频播放器 goldfire/howler.js audio player,media 2024/07/30 音频播放器 naptha/tesseract.js ocr,image,text 2025/08/28 OCR，各种语言的文字提取 openlayers/openlayers ui,maps 2025/09/27 生成可互动的地图 Leaflet/Leaflet ui,maps 2025/09/25 移动端友好的地图 jakubfiala/atrament.js ui,canvas,drawing 2025/09/26 写字板，画图板 excalidraw/excalidraw ui,canvas,drawing 2025/09/26 写字板，画图板 cozmo/jsQR image,qr code,detector 2023/12/29 二维码识别 cong-min/TagCloud ui,tagcloud,data 2024/08/15 3d 词云图生成 cypress-io/cypress test,e2e 2025/09/28 E2E 测试 mswjs/msw mock,data 2025/09/26 Mock 数据生成 faker-js/faker mock,data 2025/09/26 Mock 数据生成 fingerprintjs/fingerprintjs browser,fingerprint 2025/08/21 用户识别，部分免费 TypeScript Repository Name Keywords Last Updated Note typestack/class-validator class,transform 2025/05/02 基于 decorator 的自动类型验证 typestack/class-transformer class,transform 2025/07/21 基于 decorator 的自动类型转换 Vue Repository Name Keywords Last Updated Note vueuse/vueuse tools,utilities 2025/09/27 Vue 的常用工具集合 antfu/vite-ssg ssg,seo 2025/09/01 静态页面生成，搜索引擎 creotip/vue-particles ui,animation,background 2024/03/16 粒子背景特效 SortableJS/Vue.Draggable ui,draggable 2024/03/04 拖动方案 hilongjw/vue-lazyload ui,image,lazy load 2023/06/30 图片的懒加载方案 alvarotrigo/vue-fullpage.js ui,swipe,page 2025/08/14 fullPage.js 的封装 KABBOUCHI/vue-tippy ui,tippy,tooltip 2025/05/22 Tippy.js 的封装 meteorlxy/vue-showdown ui,markdown 2025/09/09 Showdown 的封装 vuetifyjs/vuetify ui,component 2025/09/28 基于 Material Design 的 UI 组件库 DevCloudFE/vue-devui ui,component 2025/09/08 基于 DevUI Design 的 UI 组件库 vueComponent/ant-design-vue ui,component 2025/09/25 基于 Ant Design 的 UI 组件库 element-plus/element-plus ui,component 2025/09/28 基于 Element 的 UI 组件库 youzan/vant ui,component 2025/09/25 基于 Vant 的 UI 组件库 varletjs/varlet ui,component,mobile 2025/09/12 基于 Material Design 的移动端 UI 组件库 xiaojieajie/vue3-cute-timeline ui,component,timeline 2023/03/06 时间轴组件 ndelvalle/v-click-outside user input,click 2023/03/07 点击区域检测 vuejs/pinia state,store,data 2025/09/26 状态管理，数据共享，存储 Angular Repository Name Keywords Last Updated Note KroneCorylus/ngx-colors ui,color,picker 2025/04/14 颜色选择器 swimlane/ngx-charts ui,chart 2025/09/25 图表生成 NG-ZORRO/ng-zorro-antd ui,component 2025/09/26 基于 Ant Design 的 UI 组件库 angular/components ui,component 2025/09/26 基于 Material Design 的 UI 组件库 ngrx/platform state,store,data 2025/09/25 状态管理，数据共享，存储 angular/angularfire firebase 2025/06/12 Firebase 的封装 " }, { "title": "味のしない？飴", "url": "/posts/20221105/", "categories": "日常", "tags": "", "date": "2022-11-05 10:30:00 +0900", "snippet": "最近罗森出了一款「没有味道的糖」：比较感兴趣就想买了试试，没想到连问 8 家罗森都没有卖的，回头上煤炉搜了一下惊了。相关链接 カンロ　味のしない？飴　24g｜ローソン公式サイト", "content": "最近罗森出了一款「没有味道的糖」：比较感兴趣就想买了试试，没想到连问 8 家罗森都没有卖的，回头上煤炉搜了一下惊了。相关链接 カンロ　味のしない？飴　24g｜ローソン公式サイト" }, { "title": "关于 JWT 的签名和验证", "url": "/posts/introduction-to-json-web-token/", "categories": "技术分享", "tags": "jwt, openid", "date": "2022-10-16 10:30:00 +0900", "snippet": "介绍 JWT（JSON Web Token）的文章有很多，这里主要讲一下 JWT 的签名和验证，以及为什么签名是可信的。 由于 JWT 的签名和验证过程比较繁琐，一般情况下不需要自己手动实现。 我们可以通过调用已经封装好的库来轻松验证 JWT 是否有效，以及获取里面的信息。 这里是一些可用的库：JSON Web Token Libraries - jwt.ioJWT 签名和验证的过程首...", "content": "介绍 JWT（JSON Web Token）的文章有很多，这里主要讲一下 JWT 的签名和验证，以及为什么签名是可信的。 由于 JWT 的签名和验证过程比较繁琐，一般情况下不需要自己手动实现。 我们可以通过调用已经封装好的库来轻松验证 JWT 是否有效，以及获取里面的信息。 这里是一些可用的库：JSON Web Token Libraries - jwt.ioJWT 签名和验证的过程首先来看一下 JWT 的结构，下面是一个有效的 JWT：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c这个长字符串被 2 个 . 分成 3 个部分 （segment），我们把这三个部分分别叫做 头部（Header）、载荷（Payload） 和 签名（Signature）。其中，Header 和 Payload 是通过 Base64 转码的，所以我们可以通过解码来获取实际的值：Headerbase64UrlDecode('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9')=&gt;{ \"alg\": \"HS256\", \"typ\": \"JWT\"}alg 表示签名哈希使用的算法，常用的值有 RS256（RSA-SHA256）和 HS256（HMAC-SHA256）。如果想看所有的算法可以看这篇文章：RFC 7518: JSON Web Algorithms (JWA)Payloadbase64UrlDecode('eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ')=&gt;{ \"sub\": \"1234567890\", \"name\": \"John Doe\", \"iat\": 1516239022}签名签名（Signature） 是通过对 Base64 转码后的前两部分进行哈希（SHA256）后，再进行加密得到的结果： 注意签名时使用的哈希的算法必须要在 Header 的 alg 字段里说明，这样接受方才能用对应的算法进行验证。本文的例子中用的是 HS256 算法SignatureHMAC( SHA256( eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 + \".\" + eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ ) , 'your-256-bit-secret')=&gt;SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c关于 JWT 的生成，可以记住这个公式：jwt = base64UrlEncode(header).base64UrlEncode(payload).HMAC(SHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload)), secret)验证由于 JWT 的 Payload 仅仅是通过 Base64 转码，因此我们需要验证它的真实性，以保证它不是被人篡改过的。首先我们需要对 Payload 进行 Base64 解码，并获取签名哈希的算法：（与上面相同）base64UrlDecode('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9')=&gt;{ \"alg\": \"HS256\", \"typ\": \"JWT\"}解码后，我们看到这个 JWT 使用了 HS256 算法进行签名。所以我们需要使用相应的算法和密钥来验证签名。 在 HMAC 和 RSA 算法中签名和验证都需要使用密钥，第三者在没有获得密钥的情况下无法伪造出正确的签名，所以这个验证方法是可信的。RS256 和 HS256 的区别两者的区别主要在于 RS256 是非对称算法（需要公钥和私钥），而 HS256 则是对称算法（只有私钥）。应该根据实际情况来选择合适的算法（官方则是推荐 RS256 算法）RS256由于私钥存放在本地，公钥存放在网络上并且可以随时被获取，所以可以同时为多方提供服务（如谷歌等提供的 OpenID 服务）在私钥泄露时，只需要更换本地的私钥以及网络上的公钥即可。HS256需要双方事先交换密钥，并且保证密钥的安全。如果需要同时为多方提供服务时，会导致多方共用密钥，因此不安全。密钥不慎泄露时需要双方同时更换密钥，因此比较麻烦。参考资料 JWT详解_baobao555#的博客-CSDN博客_jwt Signing and Validating JSON Web Tokens (JWT) For Everyone RFC 7519: JSON Web Token (JWT) How to Explain Public-Key Cryptography and Digital Signatures to Non-Techies jwt - RS256 vs HS256: What’s the difference? - Stack Overflow" }, { "title": "把 GitHub 的最早提交历史变为 1990 年", "url": "/posts/how-to-make-your-github-history-back-to-1990/", "categories": "技术分享", "tags": "toys, git", "date": "2022-10-09 12:00:00 +0900", "snippet": "最近发现一个有趣的仓库（GitHub - antfu/1990-script），可以把 GitHub 主页显示的提交历史变成 1990 年。看起来就像这个样子：GitHub 主页用法用法很简单，首先准备好 GitHub 用户名和 Access Token，然后执行下面的代码：$ sh -c \"$(curl -fsSL https://raw.github.com/antfu/1990-scr...", "content": "最近发现一个有趣的仓库（GitHub - antfu/1990-script），可以把 GitHub 主页显示的提交历史变成 1990 年。看起来就像这个样子：GitHub 主页用法用法很简单，首先准备好 GitHub 用户名和 Access Token，然后执行下面的代码：$ sh -c \"$(curl -fsSL https://raw.github.com/antfu/1990-script/master/index.sh)\"根据提示输入 GitHub 的用户名和 Access Token 就可以了。原理由于 Git 提交时可以使用 GIT_AUTHOR_DATE 和 GIT_COMMITTER_DATE 来手动指定时间（如果不指定则使用当前时间） 关于 GIT_AUTHOR_DATE 和 GIT_COMMITTER_DATE 的区别，可以参考这篇回答脚本中创建了一个名为 ${YEAR} 的仓库并进行了一次提交，提交时间指定为 1990 年 1 月 1 日。把这个仓库推送到 GitHub 之后，GitHub 会分析账户中的提交历史，并且展示到主页上：（2 次贡献分别为创建仓库和 README 的提交）1990 年的提交历史更详细的说明可以看仓库的 README。参考资料 GitHub - antfu/1990-script: Make your GitHub history back to 1990" }, { "title": "用 Storage 来进行前端数据持久化", "url": "/posts/persist-data-to-browser-storage/", "categories": "技术分享", "tags": "data persistence, local storage, session storage", "date": "2022-09-25 17:30:00 +0900", "snippet": "为什么要持久化？想象一个场景，在一个页面中可以设定主题是深色模式或是浅色模式（就和这个博客左侧菜单下方的按钮一样）。如果我们不做持久化，那么即使改变了主题颜色，在刷新页面之后由于数据的丢失，又会变回原来的主题。这对用户来说很不友好。为了防止数据丢失，我们可以把一些数据（或设定）存入硬盘或内存中，下次需要的时候直接读取并使用这些数据，就能够达到保存用户的数据（或设定）的目的啦。怎么持久化？在 ...", "content": "为什么要持久化？想象一个场景，在一个页面中可以设定主题是深色模式或是浅色模式（就和这个博客左侧菜单下方的按钮一样）。如果我们不做持久化，那么即使改变了主题颜色，在刷新页面之后由于数据的丢失，又会变回原来的主题。这对用户来说很不友好。为了防止数据丢失，我们可以把一些数据（或设定）存入硬盘或内存中，下次需要的时候直接读取并使用这些数据，就能够达到保存用户的数据（或设定）的目的啦。怎么持久化？在 Web 应用中持久化一般可以分为前端持久化和后端持久化，前端持久化又有几种方法： Local Storage Session Storage Cookies IndexedDB今天主要讲一下 Local Storage 和 Session Storage。Local Storagewindow.localStorage 中的数据以键值对进行存储，在浏览器的普通模式下，Local Storage 的数据会被存储到硬盘中，直到被主动删除。介绍 4 个常用的 API：// 将 theme 的值设置为 'dark'localStorage.setItem('theme', 'dark');// 获取 theme 的值const theme = localStorage.getItem('theme');// 删除 theme 键localStorage.removeItem('theme');// 删除 storage 中所有的键localStorage.clear();完整的 API 在这里：Storage - Web APIs | MDN值得注意的几个点 建议不要把敏感数据如 Token 放在 Local Storage 中。因为如果网站受到 XSS 攻击可能会导致 Local Storage 中的内容泄露。 Local Storage 中的值只能以 string 类型存储，因此如果需要存对象类型，就要自己负责转换和解析 JSON 字符串。 接上条，null，undefined 等特殊值也会被自动转成 string，因此也需要特殊处理。 在隐私（Private 或者 Incognito）模式下，Local Storage 的数据会在所有隐私模式的窗口关闭后被清除。（具体清除的时机请以各个浏览器的实现为准） 在隐私模式下，Local Storage 的数据共享模式根据不同的浏览器的实现有所不同。已知的有，Chrome 浏览器中所有的 Tab 都会共享同一个 Local Storage。而在 Safari 浏览器中，每个 Tab 的 Local Storage 都是独立的，它们之间的数据无法共享。 可存储的数据大小一般为 5MB 左右。Session Storage与 Local Storage 大致相同，主要区别是 Session Storage 生命周期只存在于一个 Session 中，每当我们打开一个新的 Tab 时，就会创建一个新的 Session，因此不同的 Tab 之间的 Session Storage 无法共享。 当 Tab 被关闭后，Session Storage 中的数据也会被清除。选择合适的 Storage我们可以根据实际需求来选择使用 Local Storage 或是 Session Storage。以设定主题颜色为例，如果使用 Local Storage，那么即使用户关闭浏览器，下次打开时也可以维持上次选择过的主题颜色。而如果使用 Session Storage，那么只能在刷新页面后维持主题颜色，当用户关闭浏览器或是新开一个 Tab 的时候又会变回初始的主题颜色。参考资料 Storage - Web APIs | MDN How Chrome Incognito keeps your browsing private - Google Chrome Help" }, { "title": "介绍几个自动生成 Markdown 链接的工具", "url": "/posts/generate-mark-down-link/", "categories": "技术分享", "tags": "markdown", "date": "2022-09-24 10:30:00 +0900", "snippet": " Markdown 是个好东西。 — Weibin Luo需要解决的问题最近在写 Markdown 的时候需要需要写一些外部的链接，按我的个人习惯一般采用这样的格式来写：[{Page Title}]({Url})举个例子：介绍几个自动生成 Markdown 链接的软件 | Amabel这么写虽然比较美观，但是每次都需要自己去 HTML 的代码中找 &lt;title&gt; 标签并取得网...", "content": " Markdown 是个好东西。 — Weibin Luo需要解决的问题最近在写 Markdown 的时候需要需要写一些外部的链接，按我的个人习惯一般采用这样的格式来写：[{Page Title}]({Url})举个例子：介绍几个自动生成 Markdown 链接的软件 | Amabel这么写虽然比较美观，但是每次都需要自己去 HTML 的代码中找 &lt;title&gt; 标签并取得网页的标题，非常花时间。于是我希望有一款工具，当我输入网页地址时可以自动取得并返回网页的标题，或是直接帮我自动生成 Markdown 格式的链接，等待我去拷贝。更甚至是直接自动帮我拷贝到剪切板，那可就太完美了。 这个功能实现起来并不困难，我在 3 年前曾做过同样的功能，可惜疏于维护。这个我们最后再说。解决思路功能比较简单，那么就说一下思路吧。我们的目标是要取得 HTML 中 &lt;head&gt; 下面 &lt;title&gt; 元素的内容，那么我们只要发起一个 GET 请求来取得网页的内容，之后解析网页的内容并取得相应元素的内容即可。获得 title 之后，我们再把 title 和 url 组合成 Markdown 格式的链接就算基本完成啦。然后有条件的话，还可以加一些自动拷贝，或是让用户自己指定输出格式的功能。 以上只能算是实现了最基本的功能。我们还需要考虑一些边界的情况。比如当返回的内容中含有 Markdown 的特殊的字符的时候，我们需要将其转义（Escape），以此来防止 XSS 攻击以及 Markdown 的格式被破坏。 典型的需要转义的 Markdown 的特殊字符有：\\ ` * _ { } [ ] ( ) # + - . ! 此外，为了防止 XSS 攻击，我们还需要将 &lt;script&gt; 标签中的字符进行转义。所以还要加上 &lt; 和 &gt; 这 2 个字符。几个现成的小工具虽说功能简单，但是把以前的项目捡起来重新维护也需要额外的时间和精力。于是尝试性地谷歌了一波之后，我找到了几个比较有意思且符合我需求的小工具。在这里分享并简单介绍一下实现的原理。 这里主要还是介绍一下本体功能的实现原理，平台（Chrome，VSCode 扩展）相关的一些东西就不写啦。Copy Title &amp; Url as Markdown Style仓库地址：GitHub - zaki-yama/copy-title-and-url-as-markdown这是一款 Chrome 扩展。看名字就知道它是干什么的了！安装扩展之后，打开你要生成链接的网页并点击扩展，大约 0.3 秒之后 Markdown 格式的链接就自动到拷贝你的剪切板了。从结果来说非常符合我的需求，美中不足的是必须自己先访问想要生成链接的网页。代码分析来看看具体是怎么实现的。我们主要关注以下几个文件： src/background.ts src/util.ts src/constant.ts在 background.ts 中，我截取了一部分关键的代码，并添加了一些注释：import { INITIAL_OPTION_VALUES } from \"./constant\";import { escapeBrackets, copyToClipboard } from \"./util\";chrome.tabs.query(queryInfo, function (tabs) { chrome.storage.local.get(INITIAL_OPTION_VALUES, function (options) { const tab = tabs[0]; // 从 Chrome 的当前 tab 中直接获取页面的 title 和 url const title = tab.title || \"\"; const url = tab.url || \"\"; const tabId = tab.id || 0; chrome.scripting.executeScript({ target: { tabId }, func: copyToClipboard, // 执行 copyToClipboard 方法 args: [options[key], title, escapeBrackets(url)], // 将 title 以及转以后的 url 作为方法的参数 }); });这个实现思路可以说是十分巧妙，通过从 Chrome 的 tab 中直接获取页面的 title 和 url，就不需要特地再去发一次 GET 请求来获得相关的信息了。另外我们还看到对 url 使用了 escapeBrackets 方法，这个方法是从 src/util.ts 中引入的。export function escapeBrackets(str: string) { return str .replace(/\\(/g, escape) .replace(/\\)/g, escape) .replace(/\\[/g, escape) .replace(/\\]/g, escape); // 对一些括号字符进行了转义}在 escapeBrackets 方法中，对一部分括号的字符进行了转义。这样可以保证页面的 title 中出现这类字符的时候也可以正常显示 Markdown 格式的链接。但由于没有对所有特殊字符进行转义，所以当 title 中出现其他特殊字符的时候可能会导致页面显示不正常。此外，由于没有转义 &lt; 和 &gt; 这 2 个字符，所以有可能会遭到 XSS 攻击。（这个地方可以考虑改进，提个 PR 什么的）最后再来看看 src/constant.ts：// markdown styleexport const DEFAULT_FORMAT = \"[${title}](${url})\";export const INITIAL_OPTION_VALUES: OptionsType = { format: DEFAULT_FORMAT, optionalFormat1: \"\", optionalFormat2: \"\",};这里主要的功能是用户可以自己定义最终输出的格式，在最终调用 copyToClipboard 时会先转换为定义好的格式在某些情况下应该比较有用。可以在设置页面自定义输出的格式markdown-link-expander仓库地址：GitHub - Skn0tt/markdown-link-expander再来看另一个。这是一个 VSCode 扩展。主要的功能是在 VSCode 中选中 url 后运行扩展，会自动把 url 替换为 Markdown 格式的链接。配合自定义的快捷键使用，可以说是直接起飞。效率起飞代码分析我们主要关注 2 个文件： src/extension.ts src/fetchTitle.ts在 src/extension.ts 中，先是进行了一些 VSCode 扩展的相关的注册，剩下的主要的部分我已经写了一些注释。首先通过 fetchTitle 方法获得页面的 title，然后转换为 Markdown 格式的链接并直接替换选中的文本：import * as vscode from \"vscode\";import { fetchTitle } from \"./fetchTitle\";export function activate(context: vscode.ExtensionContext) { const disposable = vscode.commands.registerCommand( \"markdown-link-expander.expand\", async () =&gt; { // ... const document = editor.document; const selection = editor.selection; let url = document.getText(selection); // ... await vscode.window.withProgress( { location: vscode.ProgressLocation.Notification, title: \"Fetching title ...\" }, async () =&gt; { try { const title = await fetchTitle(url); // 获取 title const markdownLink = `[${title}](${url})`; // 生成 Markdown 格式的链接 editor.edit((editBuilder) =&gt; { editBuilder.replace(selection, markdownLink); // 替换文本 }); } catch (error) { vscode.window.showErrorMessage(\"Failed to fetch title.\"); } } ); } );}再来看 src/fetchTitle.ts：import axios from \"axios\";import * as cheerio from \"cheerio\";export async function fetchTitle(url: string): Promise&lt;string&gt; { const res = await axios.get&lt;string&gt;(url); const $ = cheerio.load(res.data); const title = $(\"title\").text().trim(); return title;}和上面讲过的思路相似，fetchTitle 方法通过 axios 发起一个 GET 请求，然后使用 cherrio 解析网页，并获取 title 的内容。 需要注意的是，这个工具和上面的 Chrome 扩展一样，没有把特殊字符进行转义，所以仍然会存在格式问题和安全隐患。虽然在特殊字符的处理上不是很完美，需要手动调整，但是这个扩展对我来说已经非常够用了。作为一名开源爱好者，这个时候应该提一个改进的 PR，但是由于这个仓库好像已经 1 年多没有维护了，所以也没有提 PR 的打算。说不定将来可以 Fork 下来或者自己写一个 VSCode 扩展。3 年前的项目GitHub - Amabel/md-link是我在 3 年前写的一个小工具。实现的思路还是通过 axios 发送 GET 请求来获取页面的 title。调用它后会返回以下 JSON：{\"title\":\"Amabel's Profile\",\"url\":\"https://amabel.dev\"}当时主要是想着用 axios 来实现，但是考虑到用户端可能没有 Node.js 或是浏览器环境，所以灵机一动直接用 AWS Lambda 和 API Gateway 来做一个 API，这样用户只要通过 cURL 调用 API 就可以很快拿到结果了。 现在仔细一想，既然都可以用 cURL 了，那为什么不直接向网站发 GET 请求然后处理得到的结果呢？(我觉得这个想法非常不错，可以考虑做成一个 brew 的 formula)提几个可以改进的地方，留着以后参考： 用 Serverless 框架来改善部署的设定和步骤 提供网页版和 npm 包等多种版本，方便使用 增加对特殊字符的转义 提供多种输出格式，方便拷贝 README 要认真写！参考资料 GitHub - zaki-yama/copy-title-and-url-as-markdown GitHub - Skn0tt/markdown-link-expander Escaping special characters in markdown | TECH.SAIGONIST.COM" }, { "title": "使用 tmux 来管理终端", "url": "/posts/introduction-to-tmux/", "categories": "技术分享", "tags": "terminal, tmux", "date": "2022-09-23 18:00:00 +0900", "snippet": "为什么要用 tmux？作为一名（自称的）全栈工程师，在开发中往往会遇到需要在本地启动很多（5~10 个）服务的情况。如果我们没有办法通过 Docker 来统一管理服务（例如统一启动服务以及日志的集中管理），或是需要经常查看各个服务输出的 log 的情况下，通常只能开多个终端窗口，或是在一个窗口中开启多个标签页，这时终端往往会变成下面这个样子：请注意看顶部，有太多的标签页了这么多的标签页，我们...", "content": "为什么要用 tmux？作为一名（自称的）全栈工程师，在开发中往往会遇到需要在本地启动很多（5~10 个）服务的情况。如果我们没有办法通过 Docker 来统一管理服务（例如统一启动服务以及日志的集中管理），或是需要经常查看各个服务输出的 log 的情况下，通常只能开多个终端窗口，或是在一个窗口中开启多个标签页，这时终端往往会变成下面这个样子：请注意看顶部，有太多的标签页了这么多的标签页，我们很难快速定位到需要查看 log 的标签页（为每个标签页设定颜色可能有点用，但还是很麻烦）。这时候就轮到我们的主角 tmux 登场了。 关于 tmux 的一些基础的使用方法（比如怎么安装？）不会在本文涉及，如有需要请自行查阅文档。相关链接会放到最下面。本文主要是写一些自己的理解和使用方法，以及一些实用但又经常容易忘记的东西。介绍一下 tmuxtmux 是一款终端复用软件。翻译成人话就是你可以在一个终端内同时管理多个终端，并且可以在多个终端之间自由切换。对于上面的问题，我用 tmux 整理了一下就变成下面这个样子：（由于我使用了）使用 tmux 来管理多个终端看起来是不是高大上了许多？没错，高端程序员的终端就应该是这个样子。在这个界面中，我们可以同时看到多个不同的服务的 log，而且可以随意切换到需要的终端并使其最大化。这样一来，我们调试和写 bug 的速度一定会快很多 &gt; &lt; 由于我使用了配置文件，所以默认的界面看起来和图片上的会不太一样。tmux 中几个重要的概念Session、 window 和 pane 是 tmux 中比较重要的概念，了解这些概念可以帮助我们更好地管理多个终端。 Session 用于管理一个或多个 windows 的集合 Window 一个 window 会占据整个窗口的大小，可以将多个 windows 放入一个 session 中，并且在不同的 windows 之间自由切换。一个 window 内可以包含多个 panes Pane 一个 window 可以分割成多个 panes，一个 pane 相当于一个终端来看一下这张图：tmux 中的 session、window 和 pane上面这张图用绿色和红色标出了 window 和 pane 的概念。并且左下角标出了 session 和 windows 的名字，在这个 session 中有 2 个 windows，名字分别为 「main」 和 「chore」。下面这张图是切换 session 和 window 时的界面。这里显示了我们的电脑上总共有 3 个 sessions，并且显示了 session 下面的 windows 和 panes 的数量和名字。（切换 session 和 window 有很多种方法，这只是其中的一种）切换 session、window 和 pane 的界面掌握了这些概念，我们就可以思考一下如何管理我们的终端了。通常，我会把和某个项目相关的服务都丢进同一个 session 里面，并且把 session 命名为项目的名字。在同一个项目中可能会有很多服务（从而导致有很多 panes），这个时候我会在 session 中创建 2 个 windows，把需要一直监控的服务放到名为「main」的 window 中，把剩余不常用的服务的放到另一个 window 中，这样可以防止主要的 window 中不会有太多的 panes 而导致画面太乱的情况。另外，对于多个项目共用的一些服务，比如 Redis 或是其他数据库，也可以单独新建一个 session，或是直接通过 bg 命令丢到后台运行，取决于你需不需要经常看输出的 log。 为 sessions 和 windows 取一个好名字非常重要。值得注意的是，panes 似乎不配拥有姓名，但 tmux 会自动为每个 pane 编上序号。如何用好 tmux？首先需要说明 tmux 的操作大量依赖键盘快捷键（类似于 Vim），这对于初学的小伙伴们非常不友好。与学习 Vim 相同，为了记住这些快捷键，只能通过多用多练，慢慢地自然就会熟悉啦。我们先来看一下快捷键中 &lt;prefix&gt; 键的概念： &lt;prefix&gt; 前缀键。顾名思义，我们在按下前缀键之后才能使用对应的快捷键，否则这些快捷键会直接作用在终端而不是 tmux 上。默认的前缀键是 ⌃ + b。可以在配置文件中更改。那么怎么使用呢？举个栗子，在 tmux 中显示切换 session 和 window 的快捷键是 s，那么我们需要先按下 ⌃ + b，然后（放开 ⌃ + b）再单独按下 s，这样就会显示上面那张图的画面啦。一些常用的快捷键这里介绍一些我个人常用的快捷键。使用时请记得在前面加上 &lt;prefix&gt;。 快捷键 说明 s 显示所有的 sessions w 显示所有的 windows（与上面相似，但是会自动展开 windows） z 将当前的 pane 最大化，再按一次则还原 $ 重命名 session , 重命名 window q 显示每个 pane 的编号。在显示期间直接按下对应的数字可以快速切换到该 pane t 显示时钟 c 创建一个新的 window &amp; 关闭（删除）当前的 window % 在右边创建一个新的 pane \" 在下边创建一个新的 pane x 关闭（删除）当前的 pane 更多复杂的快捷键可以看下面的网站： Tmux Cheat Sheet &amp; Quick Reference tmux(1) - OpenBSD manual page配置文件我目前是在使用 GitHub - gpakosz/.tmux，在 GitHub 上应该算是很热门的配置文件了。介绍几点比较重要的改进： 新增了 ⌃ + a 作为 &lt;prefix&gt; 键，因为 a 和 ⌃ 的距离更近，方便使用。（⌃ + b 依然有效） UI 界面的美化，以及添加了电脑开机时间的显示 创建 pane 的快捷键从原来的 % 和 \" 改为 | 和 -，用横线和竖线来分割 pane，更加直观 新增快捷键 m 用于切换鼠标模式，在鼠标模式下可以通过点击来快速切换 pane，通过拖拽改变 pane 的大小，通过滚轮控制终端显示的滚动，选中内容后自动复制等完整的特性可以看 这里参考资料 GitHub - tmux/tmux: tmux source code Tmux Cheat Sheet &amp; Quick Reference" }, { "title": "如何重命名 Git 分支", "url": "/posts/git-rename-branch/", "categories": "技术分享", "tags": "git, branch", "date": "2022-09-23 12:00:00 +0900", "snippet": "工作中经常会遇到分支已经推到远程了之后发现命名有错误，需要修改分支名字的情况。在队友发现之前可以通过下面的步骤赶紧改回来 如果已经创建了 Pull Request 并且有 Review 之后就不建议再改名字啦，因为 GitHub 在你删除分支之后会自动关闭相关的 PR，再开新 PR 的话之前的 Review 找起来会很麻烦。1. 在本地重命名你的分支确保你已经在需要修改名字的分支上$ gi...", "content": "工作中经常会遇到分支已经推到远程了之后发现命名有错误，需要修改分支名字的情况。在队友发现之前可以通过下面的步骤赶紧改回来 如果已经创建了 Pull Request 并且有 Review 之后就不建议再改名字啦，因为 GitHub 在你删除分支之后会自动关闭相关的 PR，再开新 PR 的话之前的 Review 找起来会很麻烦。1. 在本地重命名你的分支确保你已经在需要修改名字的分支上$ git branch -m new-name2. 删除远程分支，并推送重命名后的分支$ git push origin :old-name new-name 关于使用冒号 : 来删除分支，可以看 这篇回答3. 将 upstream 重设为 origin 上新的分支$ git push origin -u new-name设定完成之后就可以正常使用啦。参考资料 Rename a local and remote branch in git – Multiple States Knowledge Base" } ]
