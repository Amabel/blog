[ { "title": "Claude Code 从入门到实践", "url": "/posts/claude-code-from-beginner-to-practice/", "categories": "技术分享", "tags": "Claude, AI, CLI, DevTools", "date": "2025-08-02 10:30:00 +0900", "snippet": "什么是 Claude Code？Claude Code 是 Anthropic 开发的命令行工具，让开发者能够在终端中直接与 Claude AI 协作进行编程任务。它不仅是一个聊天工具，更是一个强大的编程助手，能够： 读取和编辑代码文件 执行命令行操作 管理 Git 仓库 安装和配置开发环境 通过 MCP (Model Context Protocol) 扩展功能 Claude ...", "content": "什么是 Claude Code？Claude Code 是 Anthropic 开发的命令行工具，让开发者能够在终端中直接与 Claude AI 协作进行编程任务。它不仅是一个聊天工具，更是一个强大的编程助手，能够： 读取和编辑代码文件 执行命令行操作 管理 Git 仓库 安装和配置开发环境 通过 MCP (Model Context Protocol) 扩展功能 Claude Code 的核心价值在于将 AI 助手无缝集成到开发工作流程中，让编程变得更高效。快速开始安装推荐使用 npm 安装：npm install -g @anthropic-ai/claude-code也可以使用官方安装脚本：curl -fsSL https://install.anthropic.com | sh首次使用claude首次运行时会提示进行身份验证，按照指示完成配置即可。更多安装和配置详情：Claude Code 官方文档项目初始化在新项目中，可以使用 /init 命令进行智能初始化：/init该命令会： 自动分析当前代码仓库的结构和技术栈 识别项目的开发工作流程和常用命令 自动生成 CLAUDE.md 配置文件 为项目定制 Claude 的行为和响应方式 使用 /init 可以让 Claude 更好地理解你的项目，提供更精准的帮助。核心功能交互模式和快捷键Claude Code 提供多种交互模式来优化工作流程：自动接受模式 快捷键：Shift + Tab 功能：自动接受 Claude 的建议和操作 适用场景：信任 Claude 的操作时使用计划模式 (Plan Mode) 快捷键：Shift + Tab (在自动模式基础上再按一次) 功能：Claude 会先制定计划，等待用户确认后再执行 适用场景：复杂任务或需要审查的操作其他快捷键 Esc：中断当前操作 Ctrl + C：退出 Claude Code上下文管理Claude Code 支持多种方式为 AI 提供上下文信息：局部上下文 选中文本：在编辑器中选中代码后直接询问 复制粘贴： 少量文本：直接粘贴 大量文本：会显示缩略信息 截图粘贴：Ctrl + V 粘贴截图 文件引用：@filename 引用特定文件 文件夹搜索：@/ 搜索整个文件夹 URL 分析：直接输入网址让 Claude 分析网页内容整体上下文 claude -c：继续上次的会话 (continue) claude -r：恢复历史会话 (resume) /clear：清除当前会话，开始新对话 /compact &lt;指令&gt;：手动压缩会话历史记忆管理 (Claude Memories)Claude Code 支持持久化记忆功能：# 添加规则和偏好\\# 项目使用 TypeScript 严格模式\\# 代码风格遵循 Prettier 配置\\# 测试框架使用 Jest这些记忆会自动保存到文件中，在后续会话中生效。MCP (Model Context Protocol) 扩展MCP 是 Claude Code 的扩展系统，允许集成外部工具和服务。安装常用 MCP 服务Context7 - 获取最新文档和代码示例：claude mcp add --transport http context7 https://mcp.context7.com/mcpDeepWiki - GitHub 仓库文档查询：claude mcp add -s user -t http deepwiki https://mcp.deepwiki.com/mcpPlaywright - 浏览器自动化和网页操作：claude mcp add playwright npx @playwright/mcp@latestMCP 管理命令claude mcp list # 列出已安装的 MCP 服务claude mcp remove &lt;name&gt; # 移除 MCP 服务最佳实践和工作流程1. 探索-计划-编码-提交工作流探索阶段 先阅读相关文件，不急于编写代码 使用 “think” 模式触发更深入的分析 理解代码库结构和约定计划阶段 使用计划模式制定详细方案 确认方案的合理性 分解复杂任务为小步骤编码阶段 逐步实现功能 遵循项目代码风格 及时测试验证提交阶段 编写清晰的提交信息 确保代码质量2. 测试驱动开发 (TDD)# 示例工作流claude \"帮我为用户认证模块编写测试\"# Claude 编写测试用例claude \"运行测试确认失败\"# 实现功能代码claude \"再次运行测试确认通过\"3. 视觉迭代方法特别适用于前端开发： 提供设计稿或截图 Claude 实现初版 截图对比效果 迭代改进 2-3 次4. 权限管理使用 /permissions 命令管理 Claude 的操作权限：/permissions # 查看当前权限/permissions allow git # 允许 Git 操作/permissions deny file # 禁止文件编辑5. 多实例协作对于大型项目，可以： 使用多个 Claude 实例并行处理任务 利用 Git worktrees 进行独立开发 通过自定义斜杠命令简化重复工作流DevContainer 集成在 devcontainer.json 中添加 Claude Code：{ \"features\": { \"ghcr.io/devcontainers/features/node:1\": {}, \"ghcr.io/anthropics/devcontainer-features/claude-code:1\": {} }}如果已有 Node.js 环境，只需添加：{ \"features\": { \"ghcr.io/anthropics/devcontainer-features/claude-code:1\": {} }}参考：DevContainer Features 文档无头模式 (Headless Mode)Claude Code 支持在脚本中使用：# 流式输出 JSON 格式claude -p \"分析这个错误日志\" --output-format stream-json# 批处理模式claude -p \"重构这个函数\" --auto-accept适用于 CI/CD 管道和自动化脚本。CLAUDE.md 配置文件为项目创建 CLAUDE.md 文件来： 记录常用命令和脚本 定义代码风格指南 说明项目结构和约定 提供开发环境设置说明 记录已知问题和注意事项示例：# 项目配置## 开发命令npm run dev # 启动开发服务器npm run test # 运行测试npm run build # 构建生产版本## 代码风格- 使用 TypeScript 严格模式- 遵循 ESLint 和 Prettier 配置- 组件使用 PascalCase 命名## 注意事项- API 端点需要认证- 数据库连接使用环境变量常见问题和解决方案安装问题 确保 Node.js 版本 ≥ 18 检查网络连接和防火墙设置 使用 claude --version 验证安装性能优化 定期使用 /clear 清理会话 合理使用 /compact 压缩历史 避免上传过大的文件或截图权限问题 检查文件系统权限 确认 Git 仓库状态 使用 /permissions 调整权限设置进阶技巧自定义斜杠命令创建项目特定的快捷命令：# 在 CLAUDE.md 中定义/deploy # 部署到生产环境/test-all # 运行完整测试套件/lint-fix # 修复代码风格问题Git 集成最佳实践# 让 Claude 帮助生成提交信息claude \"分析这些更改并生成合适的提交信息\"# 代码审查claude \"审查这个 Pull Request 的代码质量\"# 分支管理claude \"帮我创建功能分支并设置上游\"调试工作流# 错误分析claude \"这个错误是什么原因？\" @error.log# 性能分析claude \"分析这个函数的时间复杂度\" @utils.js# 代码重构claude \"重构这个组件提高可读性\" @component.jsx参考资源 Claude Code 官方文档 Claude Code 最佳实践 MCP 协议规范 DevContainer 集成指南" }, { "title": "AWS 基础网络服务实战（一）：使用 Terraform 创建 VPC", "url": "/posts/terraform-vpc/", "categories": "技术分享", "tags": "terraform, aws, vpc, iaas", "date": "2025-06-06 10:00:00 +0900", "snippet": "VPC 基础与应用场景在 AWS 上部署服务，第一步就是构建属于自己的网络环境。VPC（Virtual Private Cloud）让你可以像搭积木一样，定制自己的云上网络结构，隔离、管理和保护你的资源。 本文将介绍如何用 Terraform 快速搭建一个自定义 VPC，并给出完整代码和最佳实践。VPC 的核心概念 CIDR 块：定义网络的 IP 范围，比如 10.0.0.0/16 子...", "content": "VPC 基础与应用场景在 AWS 上部署服务，第一步就是构建属于自己的网络环境。VPC（Virtual Private Cloud）让你可以像搭积木一样，定制自己的云上网络结构，隔离、管理和保护你的资源。 本文将介绍如何用 Terraform 快速搭建一个自定义 VPC，并给出完整代码和最佳实践。VPC 的核心概念 CIDR 块：定义网络的 IP 范围，比如 10.0.0.0/16 子网（Subnet）：VPC 内的子网络，通常分为公有和私有 路由表（Route Table）：决定流量如何在子网和外部之间流动 Internet Gateway：让 VPC 内的资源可以访问互联网 NAT Gateway：让私有子网的资源可以访问互联网，但外部无法主动访问它们一个典型的 VPC 结构，包含公有和私有子网用 Terraform 创建 VPC1. 初始化 Terraform 项目在开始之前，建议新建一个目录用于本次实验，并初始化 Terraform：mkdir terraform-vpc-demo &amp;&amp; cd terraform-vpc-demoterraform init2. 资源规划与配置说明在 AWS 网络基础设施中，通常需要以下核心资源： VPC：定义整个网络的 IP 范围，是所有资源的容器。 子网（Subnet）：VPC 内的子网络，分为公有子网（可直连互联网）和私有子网（仅内网访问）。 Internet Gateway：为公有子网提供互联网访问能力。 NAT Gateway：为私有子网提供出网能力。 路由表（Route Table）：控制子网的流量走向。下面将逐步用 Terraform 创建这些资源。创建 VPCmain.tf 示例：provider \"aws\" { region = \"ap-northeast-1\"}resource \"aws_vpc\" \"main\" { cidr_block = \"10.0.0.0/16\" # 定义 VPC 的 IP 范围 enable_dns_support = true # 启用 DNS 解析 enable_dns_hostnames = true # 启用 DNS 主机名 tags = { Name = \"demo-vpc\" }} cidr_block：VPC 的 IP 地址范围。 enable_dns_support 和 enable_dns_hostnames：建议开启，便于后续资源通过域名互通。创建公有子网、私有子网与 Internet Gateway在实际生产环境中，通常会将子网分为公有和私有： 公有子网：可直接访问互联网，适合部署 Web 服务器等需要公网访问的资源。 私有子网：无法直接访问互联网，适合部署数据库、应用服务器等内网资源。区别说明： 公有子网通过 Internet Gateway 访问互联网。 私有子网通常通过 NAT Gateway 访问互联网，外部无法主动访问。# 公有子网resource \"aws_subnet\" \"public\" { vpc_id = aws_vpc.main.id cidr_block = \"10.0.1.0/24\" # 公有子网 IP 段 availability_zone = \"ap-northeast-1a\" map_public_ip_on_launch = true # 自动分配公网 IP tags = { Name = \"public-subnet\" }}# 私有子网resource \"aws_subnet\" \"private\" { vpc_id = aws_vpc.main.id cidr_block = \"10.0.2.0/24\" # 私有子网 IP 段 availability_zone = \"ap-northeast-1a\" tags = { Name = \"private-subnet\" }}# Internet Gatewayresource \"aws_internet_gateway\" \"gw\" { vpc_id = aws_vpc.main.id tags = { Name = \"demo-igw\" }}# 公有路由表resource \"aws_route_table\" \"public\" { vpc_id = aws_vpc.main.id route { cidr_block = \"0.0.0.0/0\" gateway_id = aws_internet_gateway.gw.id } tags = { Name = \"public-rt\" }}# 公有子网关联路由表resource \"aws_route_table_association\" \"public\" { subnet_id = aws_subnet.public.id route_table_id = aws_route_table.public.id} aws_subnet.public：公有子网，自动分配公网 IP。 aws_subnet.private：私有子网，不分配公网 IP。 aws_internet_gateway.gw：为 VPC 提供互联网访问。 aws_route_table.public：公有路由表，所有流量通过 IGW 出网。 aws_route_table_association.public：将公有子网与公有路由表关联。 补充：如需让私有子网访问互联网，还需创建 NAT Gateway 和私有路由表，后续章节会详细介绍。3. 应用配置terraform planterraform apply几分钟后，你就拥有了一个带有公有和私有子网的 VPC！最佳实践 合理划分 CIDR，避免与公司内网冲突 开启 DNS 支持，方便资源间通过域名通信 资源命名规范，便于后续维护 使用变量和模块，提升可复用性（后续章节会详细介绍）参考资料 Terraform AWS Provider Docs AWS VPC 官方文档 VPC 设计最佳实践" }, { "title": "新 Mac 环境配置指南", "url": "/posts/setting-up-new-mac/", "categories": "", "tags": "Mac", "date": "2024-03-17 10:30:00 +0900", "snippet": "1. 安装 Homebrew这一步会自动安装 xcode-select，包含了常用的开发工具。/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"2. 安装常用应用以下按需安装。其它软件可在 Homebrew 查找。brew install --cask ...", "content": "1. 安装 Homebrew这一步会自动安装 xcode-select，包含了常用的开发工具。/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"2. 安装常用应用以下按需安装。其它软件可在 Homebrew 查找。brew install --cask iterm2brew install --cask google-chromebrew install --cask visual-studio-codebrew install --cask jetbrains-toolboxbrew install --cask rectanglebrew install --cask plexbrew install --cask iinabrew install --cask qqbrew install --cask wechatbrew install --cask downiebrew install --cask topnotchbrew install --cask snipastebrew install --cask dockerbrew install --cask githubbrew install --cask captinbrew install --cask notionbrew install --cask chatgptbrew install --cask cursorbrew install --cask slackbrew install --cask claude3. 安装 CLI 命令按需安装。brew install ghbrew install nvmbrew install tmuxbrew install pecobrew install mysql4. 安装 Oh My ZshmacOS Catalina 之后默认使用 zsh，可直接安装 Oh My Zsh。sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"配置 Dotfiles配置文件仓库：https://github.com/Amabel/dotfiles用以下命令直接将仓库中的文件拷贝到 Home 目录下curl --fail --silent --show-error --location https://codeload.github.com/Amabel/dotfiles/tar.gz/master | tar -x -C ~ --strip-components=15. 安装输入法谷歌日语输入法：https://www.google.co.jp/ime/搜狗输入法：https://pinyin.sogou.com/mac/6. vscode 扩展（或者通过 vscode 同步功能自动安装）code --install-extension eamodio.gitlenscode --install-extension yzhang.markdown-all-in-onecode --install-extension github.vscode-pull-request-githubcode --install-extension ms-vscode-remote.vscode-remote-extensionpackcode --install-extension vue.volarcode --install-extension esbenp.prettier-vscodecode --install-extension vscode-icons-team.vscode-iconscode --install-extension streetsidesoftware.code-spell-checkercode --install-extension oderwat.indent-rainbowcode --install-extension mechatroner.rainbow-csvcode --install-extension mkxml.vscode-filesizecode --install-extension shardulm94.trailing-spacescode --install-extension wakatime.vscode-wakatimecode --install-extension github.vscode-github-actionscode --install-extension formulahendry.auto-rename-tagcode --install-extension vincaslt.highlight-matching-tagcode --install-extension bradlc.vscode-tailwindcsscode --install-extension visualstudioexptteam.vscodeintellicodecode --install-extension codeium.codeiumcode --install-extension amazonwebservices.aws-toolkit-vscode7. 从 App Store 下载软件 iTab iBar iRightMouse Better Menubar " }, { "title": "一些关于 GitHub 设定的小技巧", "url": "/posts/tips-of-github-settings/", "categories": "技术分享", "tags": "github, git", "date": "2023-10-15 10:30:00 +0900", "snippet": "GitHubコマテク集这篇文章整理了一些关于 GitHub 的设定小技巧，可以用于团队开发中。", "content": "GitHubコマテク集这篇文章整理了一些关于 GitHub 的设定小技巧，可以用于团队开发中。" }, { "title": "在 Nginx 的容器中开启 debug 模式", "url": "/posts/nginx-enable-debug-mode/", "categories": "技术分享", "tags": "nginx, debug", "date": "2023-06-25 10:30:00 +0900", "snippet": "在使用 Nginx 的容器时候，需要开启 debug 日志来进行错误排查。步骤 1： 使用 nginx-debug 来启动容器$ docker run --name my-nginx -v /host/path/nginx.conf:/etc/nginx/nginx.conf:ro -d nginx nginx-debug -g 'daemon off;'或者当使用 docker compo...", "content": "在使用 Nginx 的容器时候，需要开启 debug 日志来进行错误排查。步骤 1： 使用 nginx-debug 来启动容器$ docker run --name my-nginx -v /host/path/nginx.conf:/etc/nginx/nginx.conf:ro -d nginx nginx-debug -g 'daemon off;'或者当使用 docker compose 时:web: image: nginx volumes: - ./nginx.conf:/etc/nginx/nginx.conf:ro command: [nginx-debug, '-g', 'daemon off;']步骤 2： 在配置文件中启用 debug 日志server { error_log logs/error.log debug;}参考资料 Docker - nginx Configuring Logging | NGINX Documentation" }, { "title": "使用 Nginx 的 X-Accel 功能从 S3 下载文件", "url": "/posts/nginx-x-accel-redirect/", "categories": "技术分享", "tags": "nginx, x-accel", "date": "2023-04-01 10:30:00 +0900", "snippet": "具体需求之前接到一个需求：前端请求下载文件后，先在后端进行权限验证，之后生成 S3 的预签名 URL，再通过 Nginx 进行文件的下载。流程图：sequenceDiagram autonumber participant browser as Browser participant nginx as Nginx participant backend as Back...", "content": "具体需求之前接到一个需求：前端请求下载文件后，先在后端进行权限验证，之后生成 S3 的预签名 URL，再通过 Nginx 进行文件的下载。流程图：sequenceDiagram autonumber participant browser as Browser participant nginx as Nginx participant backend as Backend participant s3 as AWS S3 browser -&gt;&gt; nginx: 请求下载文件： GET /download?filename=image.jpg activate nginx nginx -&gt;&gt; backend: 获取 S3 预签名 URL： GET /fileUrl?filename=image.jpg activate backend backend -&gt;&gt; backend: 验证用户身份和权限 backend -&gt;&gt; backend: 生成预签名 URL backend --&gt;&gt; nginx: 要求重定向到 S3 预签名 URL (X-Accel-Redirect) deactivate backend nginx -&gt;&gt; s3: 通过预签名 URL 请求文件内容 activate s3 s3 --&gt;&gt; nginx: 返回文件内容 deactivate s3 nginx --&gt;&gt; browser: 返回文件内容 deactivate nginx其中主要的步骤1. 前端请求获取文件前端需要展示或者下载文件时，向 Nginx发送获取文件的请求。2. Nginx 向后端请求 S3 预签名 URL由于 S3 的 Bucket 是加密的，并且 Nginx 没有权限直接访问 S3，所以要向后端请求预签名 URL 来获得访问权限。3. 后端验证用户身份权限根据实际业务需求后端可以通过请求内容（session 或 token）来验证用户的权限。4. 生成预签名 URL后端使用 S3 的访问权限来生成预签名 URL，使得任何拥有 URL 的人都可以访问文件对象。5. 要求 Nginx 重定向到 S3后端使用 Nginx 的 X-Accel 功能，通过在 Response 的 Header 中设置 X-Accel-Redirect，来让 Nginx 自动进行跳转。// 设置返回的 headersresponse.headers['X-Accel-Redirect'] = '/s3-redirect/filename/https://example-bucket.s3.amazonaws.com/example-object?key=value&amp;Expires=1672531200&amp;Signature=xxxxxx&amp;x-amz-security-token=xxxxxx&amp;x-amz-algorithm=AWS4-HMAC-SHA256' 关于 Nginx 的 X-Accel 功能，可以参考 官方文档 。6. Nginx 根据后端返回的头部进行跳转Nginx 在接收到返回之后，如果 headers 中有设置 X-Accel-Redirect 的值，那么会自动跳转到该 location。配置文件例子如下：server { # ... # 前端访问 /files?filename=xxx 时，将请求发送给后端 location /files { # 如果使用 k8s 则需要添加本地的 DNS resolver resolver kube-dns.kube-system.svc.cluster.local; # 跳转到后端地址，默认不会传递参数，所以要手动加上参数 proxy_pass http://backend.namespace.svc.cluster.local/api/file-download$is_args$args; } # 在步骤 5 中已经将 `X-Accel-Redirect` 设置为以 `s3-redirect` 开头，因此会匹配下面的 location # 并用正则表达式取出文件名和 S3 的URL，其中 $1 为文件名，$2 为跳转地址 location ~ ^/s3-redirect/(.*?)/(.*) { # 只允许内部跳转，前端无法通过输入 URL 直接访问，增强了安全性 internal; # 由于要跳转到 S3 的地址，需要加上外部 DNS，这里用谷歌的 DNS resolver 8.8.8.8; # 跳转到 S3 并下载文件，同样记得带上参数 proxy_pass $2$is_args$args; # 添加头部，若为图片等可以内联展示的文件则直接展示，如果不能（PDF 等文件）则下载文件并保存为指定的文件名 add_header Content-Disposition 'inline; filename=\"$1\"'; }}上面的例子是真实案例，可以根据实际情况简化一些设置，比如不需要 k8s 的 DNS resolver 设置，以及不需要文件下载的相关设置。 关于 Nginx 的 内置变量，可以参考 官方文档 。 关于 Nginx 默认不会传递查询参数，可以看这篇回答。总结当时踩的几个坑 k8s 通过 service 名来访问其他 service 的时候需要加上本地的 DNS resolver proxy_pass 默认不会传递参数，需要用内置变量手动传递 Nginx 的路径匹配规则，正则匹配，贪婪和非贪婪 internal 关键字 跳转到外部时需要加上外部的 DNS resolver 手动添加 headers 来控制文件的下载参考资料 S3 の非公開ファイルを nginx X-Accel-Redirect と Rails の認証セッションを使って限定公開する | Basicinc Enjoy Hacking! Nginx proxy Amazon S3 resources - Stack Overflow" }, { "title": "新的工作地点", "url": "/posts/new-work-place/", "categories": "日常", "tags": "", "date": "2023-01-04 10:30:00 +0900", "snippet": "新的工作地点。可以看到东京塔和富士山", "content": "新的工作地点。可以看到东京塔和富士山" }, { "title": "一些 JavaScript 的库的整理", "url": "/posts/awesome-js-libraries/", "categories": "技术分享", "tags": "library, awesome", "date": "2022-12-12 10:30:00 +0900", "snippet": "分享一些开源 JavaScript 库，以及它们的维护情况。JavaScript Repository Name Keywords Last Updated Note saadeghi/daisyui ui,component 2025/08/09 基于 Tailwind 的 ...", "content": "分享一些开源 JavaScript 库，以及它们的维护情况。JavaScript Repository Name Keywords Last Updated Note saadeghi/daisyui ui,component 2025/08/09 基于 Tailwind 的 UI 组件库 atomiks/tippyjs ui,tooltip,dropdown 2024/05/27 提示标签 floating-ui/floating-ui ui,anchor 2025/07/30 实现各种组件的定位、漂浮效果 notiflix/Notiflix ui,alert,notification 2025/01/04 通知，加载，提示框等方案 fengyuanchen/viewerjs ui,image,viewer 2025/01/05 图片查看，画廊 fengyuanchen/cropperjs ui,image 2025/07/25 图像裁剪 wagerfield/parallax ui,image,animation 2024/04/06 使用陀螺仪或鼠标生成视差特效 mattboldt/typed.js ui,typing,animation 2025/02/07 打字机特效 nolimits4web/swiper ui,slide 2025/08/05 幻灯片效果 kenwheeler/slick ui,slide,carousel 2025/07/26 幻灯片效果 slidevjs/slidev ui,slide 2025/08/06 幻灯片效果 sindresorhus/screenfull ui,full screen 2022/07/08 全屏显示 alvarotrigo/fullPage.js ui,swipe,page 2025/06/28 整页效果 hakimel/reveal.js ui,swipe,mobile 2025/08/05 移动端的页面滑动方案 usablica/intro.js ui,onboarding 2025/07/27 界面操作引导 benhowdle89/grade ui,image,color 2022/08/02 根据图片颜色自动生成背景色 highlightjs/highlight.js ui,text,markdown,code 2025/07/07 代码高亮 VincentGarreau/particles.js ui,animation,background 2024/03/28 粒子背景特效 mrdoob/three.js ui,animation,3d 2025/08/09 3D 特效引擎 juliangarnier/anime ui,animation 2025/08/04 动画特效引擎 showdownjs/showdown ui,markdown 2024/08/20 Markdown 转换工具 markedjs/marked ui,markdown 2025/08/04 Markdown 转换工具 codex-team/editor.js ui,editor,text 2025/04/30 功能强大的编辑器 niklasvh/html2canvas ui,html,canvas 2024/07/18 将 HTML 转换为 Canvas。用于保存或展示 ustbhuangyi/better-scroll ui,scroll 2024/06/14 移动端的页面滑动增强 d3/d3 ui,data,chart 2025/07/27 根据数据生成图表 chartjs/Chart.js ui,data,chart 2025/08/06 图表生成 apache/echarts ui,data,chart 2025/08/09 图表生成 mozilla/pdf.js ui,pdf reader 2025/08/07 PDF 阅读器 zenorocha/clipboard.js clipboard 2025/08/06 剪贴板 js-cookie/js-cookie cookie 2025/06/15 Cookie 的使用 eligrey/FileSaver.js file,save 2023/03/01 保存为本地文件 adamwdraper/Numeral-js input,number,currency 2024/04/24 精确的数字计算 scurker/currency.js input,number,currency 2025/08/09 货币运算 hapijs/joi input,data,validation 2025/08/09 数据验证，输入验证 ten1seven/what-input input,detector 2025/02/17 用户输入检测 ccampbell/mousetrap input,keyboard 2023/03/15 键盘快捷键方案 uNmAnNeR/imaskjs format,text,number 2024/10/11 自定义格式，自动格式化输入文本 nosir/cleave.js format,text,number 2023/11/25 自定义格式，自动格式化输入文本 moment/moment format,date,time 2024/08/14 格式化时间、日期 moment/luxon format,date,time 2025/07/29 格式化时间、日期。轻量 iamkun/dayjs format,date,time 2025/07/21 格式化时间、日期。更轻量 date-fns/date-fns format,date,time 2025/07/30 格式化时间、日期 vercel/ms time,converter 2025/07/31 将各种时间转换为毫秒 blakeembrey/change-case converter,case 2025/06/17 各种大小写格式的转换 reactivex/rxjs rx,reactive 2025/02/23 响应式编程解决方案 faisalman/ua-parser-js user agent,browser,environment 2025/08/09 用户 UA 检测 axios/axios http,request,network 2025/08/07 HTTP 请求 softonic/axios-retry http,request,axios 2025/06/17 axios 的重试插件 i18next/i18next i18n,translate,language 2025/07/09 国际化 justadudewhohacks/face-api.js face detection,computer vision 2024/01/24 面部识别 mpetroff/pannellum image,panorama,3d 2025/06/28 根据图片生成全景模式 DIYgod/DPlayer video player,media 2025/05/16 视频播放器。可以实现弹幕功能 videojs/video.js video player,media 2025/08/01 视频播放器 sampotts/plyr video player,media 2024/06/29 视频播放器 BMSVieira/moovie.js video player,media 2025/01/03 又一个视频播放器 goldfire/howler.js audio player,media 2024/07/30 音频播放器 naptha/tesseract.js ocr,image,text 2025/08/06 OCR，各种语言的文字提取 openlayers/openlayers ui,maps 2025/08/08 生成可互动的地图 Leaflet/Leaflet ui,maps 2025/08/08 移动端友好的地图 jakubfiala/atrament.js ui,canvas,drawing 2025/07/16 写字板，画图板 excalidraw/excalidraw ui,canvas,drawing 2025/08/08 写字板，画图板 cozmo/jsQR image,qr code,detector 2023/12/29 二维码识别 cong-min/TagCloud ui,tagcloud,data 2024/08/15 3d 词云图生成 cypress-io/cypress test,e2e 2025/08/08 E2E 测试 mswjs/msw mock,data 2025/07/31 Mock 数据生成 faker-js/faker mock,data 2025/08/09 Mock 数据生成 fingerprintjs/fingerprintjs browser,fingerprint 2025/08/06 用户识别，部分免费 TypeScript Repository Name Keywords Last Updated Note typestack/class-validator class,transform 2025/05/02 基于 decorator 的自动类型验证 typestack/class-transformer class,transform 2025/07/21 基于 decorator 的自动类型转换 Vue Repository Name Keywords Last Updated Note vueuse/vueuse tools,utilities 2025/08/09 Vue 的常用工具集合 antfu/vite-ssg ssg,seo 2025/07/29 静态页面生成，搜索引擎 creotip/vue-particles ui,animation,background 2024/03/16 粒子背景特效 SortableJS/Vue.Draggable ui,draggable 2024/03/04 拖动方案 hilongjw/vue-lazyload ui,image,lazy load 2023/06/30 图片的懒加载方案 alvarotrigo/vue-fullpage.js ui,swipe,page 2025/06/27 fullPage.js 的封装 KABBOUCHI/vue-tippy ui,tippy,tooltip 2025/05/22 Tippy.js 的封装 meteorlxy/vue-showdown ui,markdown 2025/07/07 Showdown 的封装 vuetifyjs/vuetify ui,component 2025/08/10 基于 Material Design 的 UI 组件库 DevCloudFE/vue-devui ui,component 2025/06/17 基于 DevUI Design 的 UI 组件库 vueComponent/ant-design-vue ui,component 2025/08/04 基于 Ant Design 的 UI 组件库 element-plus/element-plus ui,component 2025/08/09 基于 Element 的 UI 组件库 youzan/vant ui,component 2025/08/08 基于 Vant 的 UI 组件库 varletjs/varlet ui,component,mobile 2025/07/30 基于 Material Design 的移动端 UI 组件库 xiaojieajie/vue3-cute-timeline ui,component,timeline 2023/03/06 时间轴组件 ndelvalle/v-click-outside user input,click 2023/03/07 点击区域检测 vuejs/pinia state,store,data 2025/08/07 状态管理，数据共享，存储 Angular Repository Name Keywords Last Updated Note KroneCorylus/ngx-colors ui,color,picker 2025/04/14 颜色选择器 swimlane/ngx-charts ui,chart 2025/08/06 图表生成 NG-ZORRO/ng-zorro-antd ui,component 2025/08/08 基于 Ant Design 的 UI 组件库 angular/components ui,component 2025/08/08 基于 Material Design 的 UI 组件库 ngrx/platform state,store,data 2025/08/09 状态管理，数据共享，存储 angular/angularfire firebase 2025/06/12 Firebase 的封装 " }, { "title": "味のしない？飴", "url": "/posts/20221105/", "categories": "日常", "tags": "", "date": "2022-11-05 10:30:00 +0900", "snippet": "最近罗森出了一款「没有味道的糖」：比较感兴趣就想买了试试，没想到连问 8 家罗森都没有卖的，回头上煤炉搜了一下惊了。相关链接 カンロ　味のしない？飴　24g｜ローソン公式サイト", "content": "最近罗森出了一款「没有味道的糖」：比较感兴趣就想买了试试，没想到连问 8 家罗森都没有卖的，回头上煤炉搜了一下惊了。相关链接 カンロ　味のしない？飴　24g｜ローソン公式サイト" }, { "title": "关于 JWT 的签名和验证", "url": "/posts/introduction-to-json-web-token/", "categories": "技术分享", "tags": "jwt, openid", "date": "2022-10-16 10:30:00 +0900", "snippet": "介绍 JWT（JSON Web Token）的文章有很多，这里主要讲一下 JWT 的签名和验证，以及为什么签名是可信的。 由于 JWT 的签名和验证过程比较繁琐，一般情况下不需要自己手动实现。 我们可以通过调用已经封装好的库来轻松验证 JWT 是否有效，以及获取里面的信息。 这里是一些可用的库：JSON Web Token Libraries - jwt.ioJWT 签名和验证的过程首...", "content": "介绍 JWT（JSON Web Token）的文章有很多，这里主要讲一下 JWT 的签名和验证，以及为什么签名是可信的。 由于 JWT 的签名和验证过程比较繁琐，一般情况下不需要自己手动实现。 我们可以通过调用已经封装好的库来轻松验证 JWT 是否有效，以及获取里面的信息。 这里是一些可用的库：JSON Web Token Libraries - jwt.ioJWT 签名和验证的过程首先来看一下 JWT 的结构，下面是一个有效的 JWT：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c这个长字符串被 2 个 . 分成 3 个部分 （segment），我们把这三个部分分别叫做 头部（Header）、载荷（Payload） 和 签名（Signature）。其中，Header 和 Payload 是通过 Base64 转码的，所以我们可以通过解码来获取实际的值：Headerbase64UrlDecode('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9')=&gt;{ \"alg\": \"HS256\", \"typ\": \"JWT\"}alg 表示签名哈希使用的算法，常用的值有 RS256（RSA-SHA256）和 HS256（HMAC-SHA256）。如果想看所有的算法可以看这篇文章：RFC 7518: JSON Web Algorithms (JWA)Payloadbase64UrlDecode('eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ')=&gt;{ \"sub\": \"1234567890\", \"name\": \"John Doe\", \"iat\": 1516239022}签名签名（Signature） 是通过对 Base64 转码后的前两部分进行哈希（SHA256）后，再进行加密得到的结果： 注意签名时使用的哈希的算法必须要在 Header 的 alg 字段里说明，这样接受方才能用对应的算法进行验证。本文的例子中用的是 HS256 算法SignatureHMAC( SHA256( eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 + \".\" + eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ ) , 'your-256-bit-secret')=&gt;SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c关于 JWT 的生成，可以记住这个公式：jwt = base64UrlEncode(header).base64UrlEncode(payload).HMAC(SHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload)), secret)验证由于 JWT 的 Payload 仅仅是通过 Base64 转码，因此我们需要验证它的真实性，以保证它不是被人篡改过的。首先我们需要对 Payload 进行 Base64 解码，并获取签名哈希的算法：（与上面相同）base64UrlDecode('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9')=&gt;{ \"alg\": \"HS256\", \"typ\": \"JWT\"}解码后，我们看到这个 JWT 使用了 HS256 算法进行签名。所以我们需要使用相应的算法和密钥来验证签名。 在 HMAC 和 RSA 算法中签名和验证都需要使用密钥，第三者在没有获得密钥的情况下无法伪造出正确的签名，所以这个验证方法是可信的。RS256 和 HS256 的区别两者的区别主要在于 RS256 是非对称算法（需要公钥和私钥），而 HS256 则是对称算法（只有私钥）。应该根据实际情况来选择合适的算法（官方则是推荐 RS256 算法）RS256由于私钥存放在本地，公钥存放在网络上并且可以随时被获取，所以可以同时为多方提供服务（如谷歌等提供的 OpenID 服务）在私钥泄露时，只需要更换本地的私钥以及网络上的公钥即可。HS256需要双方事先交换密钥，并且保证密钥的安全。如果需要同时为多方提供服务时，会导致多方共用密钥，因此不安全。密钥不慎泄露时需要双方同时更换密钥，因此比较麻烦。参考资料 JWT详解_baobao555#的博客-CSDN博客_jwt Signing and Validating JSON Web Tokens (JWT) For Everyone RFC 7519: JSON Web Token (JWT) How to Explain Public-Key Cryptography and Digital Signatures to Non-Techies jwt - RS256 vs HS256: What’s the difference? - Stack Overflow" }, { "title": "把 GitHub 的最早提交历史变为 1990 年", "url": "/posts/how-to-make-your-github-history-back-to-1990/", "categories": "技术分享", "tags": "toys, git", "date": "2022-10-09 12:00:00 +0900", "snippet": "最近发现一个有趣的仓库（GitHub - antfu/1990-script），可以把 GitHub 主页显示的提交历史变成 1990 年。看起来就像这个样子：GitHub 主页用法用法很简单，首先准备好 GitHub 用户名和 Access Token，然后执行下面的代码：$ sh -c \"$(curl -fsSL https://raw.github.com/antfu/1990-scr...", "content": "最近发现一个有趣的仓库（GitHub - antfu/1990-script），可以把 GitHub 主页显示的提交历史变成 1990 年。看起来就像这个样子：GitHub 主页用法用法很简单，首先准备好 GitHub 用户名和 Access Token，然后执行下面的代码：$ sh -c \"$(curl -fsSL https://raw.github.com/antfu/1990-script/master/index.sh)\"根据提示输入 GitHub 的用户名和 Access Token 就可以了。原理由于 Git 提交时可以使用 GIT_AUTHOR_DATE 和 GIT_COMMITTER_DATE 来手动指定时间（如果不指定则使用当前时间） 关于 GIT_AUTHOR_DATE 和 GIT_COMMITTER_DATE 的区别，可以参考这篇回答脚本中创建了一个名为 ${YEAR} 的仓库并进行了一次提交，提交时间指定为 1990 年 1 月 1 日。把这个仓库推送到 GitHub 之后，GitHub 会分析账户中的提交历史，并且展示到主页上：（2 次贡献分别为创建仓库和 README 的提交）1990 年的提交历史更详细的说明可以看仓库的 README。参考资料 GitHub - antfu/1990-script: Make your GitHub history back to 1990" }, { "title": "用 Storage 来进行前端数据持久化", "url": "/posts/persist-data-to-browser-storage/", "categories": "技术分享", "tags": "data persistence, local storage, session storage", "date": "2022-09-25 17:30:00 +0900", "snippet": "为什么要持久化？想象一个场景，在一个页面中可以设定主题是深色模式或是浅色模式（就和这个博客左侧菜单下方的按钮一样）。如果我们不做持久化，那么即使改变了主题颜色，在刷新页面之后由于数据的丢失，又会变回原来的主题。这对用户来说很不友好。为了防止数据丢失，我们可以把一些数据（或设定）存入硬盘或内存中，下次需要的时候直接读取并使用这些数据，就能够达到保存用户的数据（或设定）的目的啦。怎么持久化？在 ...", "content": "为什么要持久化？想象一个场景，在一个页面中可以设定主题是深色模式或是浅色模式（就和这个博客左侧菜单下方的按钮一样）。如果我们不做持久化，那么即使改变了主题颜色，在刷新页面之后由于数据的丢失，又会变回原来的主题。这对用户来说很不友好。为了防止数据丢失，我们可以把一些数据（或设定）存入硬盘或内存中，下次需要的时候直接读取并使用这些数据，就能够达到保存用户的数据（或设定）的目的啦。怎么持久化？在 Web 应用中持久化一般可以分为前端持久化和后端持久化，前端持久化又有几种方法： Local Storage Session Storage Cookies IndexedDB今天主要讲一下 Local Storage 和 Session Storage。Local Storagewindow.localStorage 中的数据以键值对进行存储，在浏览器的普通模式下，Local Storage 的数据会被存储到硬盘中，直到被主动删除。介绍 4 个常用的 API：// 将 theme 的值设置为 'dark'localStorage.setItem('theme', 'dark');// 获取 theme 的值const theme = localStorage.getItem('theme');// 删除 theme 键localStorage.removeItem('theme');// 删除 storage 中所有的键localStorage.clear();完整的 API 在这里：Storage - Web APIs | MDN值得注意的几个点 建议不要把敏感数据如 Token 放在 Local Storage 中。因为如果网站受到 XSS 攻击可能会导致 Local Storage 中的内容泄露。 Local Storage 中的值只能以 string 类型存储，因此如果需要存对象类型，就要自己负责转换和解析 JSON 字符串。 接上条，null，undefined 等特殊值也会被自动转成 string，因此也需要特殊处理。 在隐私（Private 或者 Incognito）模式下，Local Storage 的数据会在所有隐私模式的窗口关闭后被清除。（具体清除的时机请以各个浏览器的实现为准） 在隐私模式下，Local Storage 的数据共享模式根据不同的浏览器的实现有所不同。已知的有，Chrome 浏览器中所有的 Tab 都会共享同一个 Local Storage。而在 Safari 浏览器中，每个 Tab 的 Local Storage 都是独立的，它们之间的数据无法共享。 可存储的数据大小一般为 5MB 左右。Session Storage与 Local Storage 大致相同，主要区别是 Session Storage 生命周期只存在于一个 Session 中，每当我们打开一个新的 Tab 时，就会创建一个新的 Session，因此不同的 Tab 之间的 Session Storage 无法共享。 当 Tab 被关闭后，Session Storage 中的数据也会被清除。选择合适的 Storage我们可以根据实际需求来选择使用 Local Storage 或是 Session Storage。以设定主题颜色为例，如果使用 Local Storage，那么即使用户关闭浏览器，下次打开时也可以维持上次选择过的主题颜色。而如果使用 Session Storage，那么只能在刷新页面后维持主题颜色，当用户关闭浏览器或是新开一个 Tab 的时候又会变回初始的主题颜色。参考资料 Storage - Web APIs | MDN How Chrome Incognito keeps your browsing private - Google Chrome Help" }, { "title": "介绍几个自动生成 Markdown 链接的工具", "url": "/posts/generate-mark-down-link/", "categories": "技术分享", "tags": "markdown", "date": "2022-09-24 10:30:00 +0900", "snippet": " Markdown 是个好东西。 — Weibin Luo需要解决的问题最近在写 Markdown 的时候需要需要写一些外部的链接，按我的个人习惯一般采用这样的格式来写：[{Page Title}]({Url})举个例子：介绍几个自动生成 Markdown 链接的软件 | Amabel这么写虽然比较美观，但是每次都需要自己去 HTML 的代码中找 &lt;title&gt; 标签并取得网...", "content": " Markdown 是个好东西。 — Weibin Luo需要解决的问题最近在写 Markdown 的时候需要需要写一些外部的链接，按我的个人习惯一般采用这样的格式来写：[{Page Title}]({Url})举个例子：介绍几个自动生成 Markdown 链接的软件 | Amabel这么写虽然比较美观，但是每次都需要自己去 HTML 的代码中找 &lt;title&gt; 标签并取得网页的标题，非常花时间。于是我希望有一款工具，当我输入网页地址时可以自动取得并返回网页的标题，或是直接帮我自动生成 Markdown 格式的链接，等待我去拷贝。更甚至是直接自动帮我拷贝到剪切板，那可就太完美了。 这个功能实现起来并不困难，我在 3 年前曾做过同样的功能，可惜疏于维护。这个我们最后再说。解决思路功能比较简单，那么就说一下思路吧。我们的目标是要取得 HTML 中 &lt;head&gt; 下面 &lt;title&gt; 元素的内容，那么我们只要发起一个 GET 请求来取得网页的内容，之后解析网页的内容并取得相应元素的内容即可。获得 title 之后，我们再把 title 和 url 组合成 Markdown 格式的链接就算基本完成啦。然后有条件的话，还可以加一些自动拷贝，或是让用户自己指定输出格式的功能。 以上只能算是实现了最基本的功能。我们还需要考虑一些边界的情况。比如当返回的内容中含有 Markdown 的特殊的字符的时候，我们需要将其转义（Escape），以此来防止 XSS 攻击以及 Markdown 的格式被破坏。 典型的需要转义的 Markdown 的特殊字符有：\\ ` * _ { } [ ] ( ) # + - . ! 此外，为了防止 XSS 攻击，我们还需要将 &lt;script&gt; 标签中的字符进行转义。所以还要加上 &lt; 和 &gt; 这 2 个字符。几个现成的小工具虽说功能简单，但是把以前的项目捡起来重新维护也需要额外的时间和精力。于是尝试性地谷歌了一波之后，我找到了几个比较有意思且符合我需求的小工具。在这里分享并简单介绍一下实现的原理。 这里主要还是介绍一下本体功能的实现原理，平台（Chrome，VSCode 扩展）相关的一些东西就不写啦。Copy Title &amp; Url as Markdown Style仓库地址：GitHub - zaki-yama/copy-title-and-url-as-markdown这是一款 Chrome 扩展。看名字就知道它是干什么的了！安装扩展之后，打开你要生成链接的网页并点击扩展，大约 0.3 秒之后 Markdown 格式的链接就自动到拷贝你的剪切板了。从结果来说非常符合我的需求，美中不足的是必须自己先访问想要生成链接的网页。代码分析来看看具体是怎么实现的。我们主要关注以下几个文件： src/background.ts src/util.ts src/constant.ts在 background.ts 中，我截取了一部分关键的代码，并添加了一些注释：import { INITIAL_OPTION_VALUES } from \"./constant\";import { escapeBrackets, copyToClipboard } from \"./util\";chrome.tabs.query(queryInfo, function (tabs) { chrome.storage.local.get(INITIAL_OPTION_VALUES, function (options) { const tab = tabs[0]; // 从 Chrome 的当前 tab 中直接获取页面的 title 和 url const title = tab.title || \"\"; const url = tab.url || \"\"; const tabId = tab.id || 0; chrome.scripting.executeScript({ target: { tabId }, func: copyToClipboard, // 执行 copyToClipboard 方法 args: [options[key], title, escapeBrackets(url)], // 将 title 以及转以后的 url 作为方法的参数 }); });这个实现思路可以说是十分巧妙，通过从 Chrome 的 tab 中直接获取页面的 title 和 url，就不需要特地再去发一次 GET 请求来获得相关的信息了。另外我们还看到对 url 使用了 escapeBrackets 方法，这个方法是从 src/util.ts 中引入的。export function escapeBrackets(str: string) { return str .replace(/\\(/g, escape) .replace(/\\)/g, escape) .replace(/\\[/g, escape) .replace(/\\]/g, escape); // 对一些括号字符进行了转义}在 escapeBrackets 方法中，对一部分括号的字符进行了转义。这样可以保证页面的 title 中出现这类字符的时候也可以正常显示 Markdown 格式的链接。但由于没有对所有特殊字符进行转义，所以当 title 中出现其他特殊字符的时候可能会导致页面显示不正常。此外，由于没有转义 &lt; 和 &gt; 这 2 个字符，所以有可能会遭到 XSS 攻击。（这个地方可以考虑改进，提个 PR 什么的）最后再来看看 src/constant.ts：// markdown styleexport const DEFAULT_FORMAT = \"[${title}](${url})\";export const INITIAL_OPTION_VALUES: OptionsType = { format: DEFAULT_FORMAT, optionalFormat1: \"\", optionalFormat2: \"\",};这里主要的功能是用户可以自己定义最终输出的格式，在最终调用 copyToClipboard 时会先转换为定义好的格式在某些情况下应该比较有用。可以在设置页面自定义输出的格式markdown-link-expander仓库地址：GitHub - Skn0tt/markdown-link-expander再来看另一个。这是一个 VSCode 扩展。主要的功能是在 VSCode 中选中 url 后运行扩展，会自动把 url 替换为 Markdown 格式的链接。配合自定义的快捷键使用，可以说是直接起飞。效率起飞代码分析我们主要关注 2 个文件： src/extension.ts src/fetchTitle.ts在 src/extension.ts 中，先是进行了一些 VSCode 扩展的相关的注册，剩下的主要的部分我已经写了一些注释。首先通过 fetchTitle 方法获得页面的 title，然后转换为 Markdown 格式的链接并直接替换选中的文本：import * as vscode from \"vscode\";import { fetchTitle } from \"./fetchTitle\";export function activate(context: vscode.ExtensionContext) { const disposable = vscode.commands.registerCommand( \"markdown-link-expander.expand\", async () =&gt; { // ... const document = editor.document; const selection = editor.selection; let url = document.getText(selection); // ... await vscode.window.withProgress( { location: vscode.ProgressLocation.Notification, title: \"Fetching title ...\" }, async () =&gt; { try { const title = await fetchTitle(url); // 获取 title const markdownLink = `[${title}](${url})`; // 生成 Markdown 格式的链接 editor.edit((editBuilder) =&gt; { editBuilder.replace(selection, markdownLink); // 替换文本 }); } catch (error) { vscode.window.showErrorMessage(\"Failed to fetch title.\"); } } ); } );}再来看 src/fetchTitle.ts：import axios from \"axios\";import * as cheerio from \"cheerio\";export async function fetchTitle(url: string): Promise&lt;string&gt; { const res = await axios.get&lt;string&gt;(url); const $ = cheerio.load(res.data); const title = $(\"title\").text().trim(); return title;}和上面讲过的思路相似，fetchTitle 方法通过 axios 发起一个 GET 请求，然后使用 cherrio 解析网页，并获取 title 的内容。 需要注意的是，这个工具和上面的 Chrome 扩展一样，没有把特殊字符进行转义，所以仍然会存在格式问题和安全隐患。虽然在特殊字符的处理上不是很完美，需要手动调整，但是这个扩展对我来说已经非常够用了。作为一名开源爱好者，这个时候应该提一个改进的 PR，但是由于这个仓库好像已经 1 年多没有维护了，所以也没有提 PR 的打算。说不定将来可以 Fork 下来或者自己写一个 VSCode 扩展。3 年前的项目GitHub - Amabel/md-link是我在 3 年前写的一个小工具。实现的思路还是通过 axios 发送 GET 请求来获取页面的 title。调用它后会返回以下 JSON：{\"title\":\"Amabel's Profile\",\"url\":\"https://amabel.dev\"}当时主要是想着用 axios 来实现，但是考虑到用户端可能没有 Node.js 或是浏览器环境，所以灵机一动直接用 AWS Lambda 和 API Gateway 来做一个 API，这样用户只要通过 cURL 调用 API 就可以很快拿到结果了。 现在仔细一想，既然都可以用 cURL 了，那为什么不直接向网站发 GET 请求然后处理得到的结果呢？(我觉得这个想法非常不错，可以考虑做成一个 brew 的 formula)提几个可以改进的地方，留着以后参考： 用 Serverless 框架来改善部署的设定和步骤 提供网页版和 npm 包等多种版本，方便使用 增加对特殊字符的转义 提供多种输出格式，方便拷贝 README 要认真写！参考资料 GitHub - zaki-yama/copy-title-and-url-as-markdown GitHub - Skn0tt/markdown-link-expander Escaping special characters in markdown | TECH.SAIGONIST.COM" }, { "title": "使用 tmux 来管理终端", "url": "/posts/introduction-to-tmux/", "categories": "技术分享", "tags": "terminal, tmux", "date": "2022-09-23 18:00:00 +0900", "snippet": "为什么要用 tmux？作为一名（自称的）全栈工程师，在开发中往往会遇到需要在本地启动很多（5~10 个）服务的情况。如果我们没有办法通过 Docker 来统一管理服务（例如统一启动服务以及日志的集中管理），或是需要经常查看各个服务输出的 log 的情况下，通常只能开多个终端窗口，或是在一个窗口中开启多个标签页，这时终端往往会变成下面这个样子：请注意看顶部，有太多的标签页了这么多的标签页，我们...", "content": "为什么要用 tmux？作为一名（自称的）全栈工程师，在开发中往往会遇到需要在本地启动很多（5~10 个）服务的情况。如果我们没有办法通过 Docker 来统一管理服务（例如统一启动服务以及日志的集中管理），或是需要经常查看各个服务输出的 log 的情况下，通常只能开多个终端窗口，或是在一个窗口中开启多个标签页，这时终端往往会变成下面这个样子：请注意看顶部，有太多的标签页了这么多的标签页，我们很难快速定位到需要查看 log 的标签页（为每个标签页设定颜色可能有点用，但还是很麻烦）。这时候就轮到我们的主角 tmux 登场了。 关于 tmux 的一些基础的使用方法（比如怎么安装？）不会在本文涉及，如有需要请自行查阅文档。相关链接会放到最下面。本文主要是写一些自己的理解和使用方法，以及一些实用但又经常容易忘记的东西。介绍一下 tmuxtmux 是一款终端复用软件。翻译成人话就是你可以在一个终端内同时管理多个终端，并且可以在多个终端之间自由切换。对于上面的问题，我用 tmux 整理了一下就变成下面这个样子：（由于我使用了）使用 tmux 来管理多个终端看起来是不是高大上了许多？没错，高端程序员的终端就应该是这个样子。在这个界面中，我们可以同时看到多个不同的服务的 log，而且可以随意切换到需要的终端并使其最大化。这样一来，我们调试和写 bug 的速度一定会快很多 &gt; &lt; 由于我使用了配置文件，所以默认的界面看起来和图片上的会不太一样。tmux 中几个重要的概念Session、 window 和 pane 是 tmux 中比较重要的概念，了解这些概念可以帮助我们更好地管理多个终端。 Session 用于管理一个或多个 windows 的集合 Window 一个 window 会占据整个窗口的大小，可以将多个 windows 放入一个 session 中，并且在不同的 windows 之间自由切换。一个 window 内可以包含多个 panes Pane 一个 window 可以分割成多个 panes，一个 pane 相当于一个终端来看一下这张图：tmux 中的 session、window 和 pane上面这张图用绿色和红色标出了 window 和 pane 的概念。并且左下角标出了 session 和 windows 的名字，在这个 session 中有 2 个 windows，名字分别为 「main」 和 「chore」。下面这张图是切换 session 和 window 时的界面。这里显示了我们的电脑上总共有 3 个 sessions，并且显示了 session 下面的 windows 和 panes 的数量和名字。（切换 session 和 window 有很多种方法，这只是其中的一种）切换 session、window 和 pane 的界面掌握了这些概念，我们就可以思考一下如何管理我们的终端了。通常，我会把和某个项目相关的服务都丢进同一个 session 里面，并且把 session 命名为项目的名字。在同一个项目中可能会有很多服务（从而导致有很多 panes），这个时候我会在 session 中创建 2 个 windows，把需要一直监控的服务放到名为「main」的 window 中，把剩余不常用的服务的放到另一个 window 中，这样可以防止主要的 window 中不会有太多的 panes 而导致画面太乱的情况。另外，对于多个项目共用的一些服务，比如 Redis 或是其他数据库，也可以单独新建一个 session，或是直接通过 bg 命令丢到后台运行，取决于你需不需要经常看输出的 log。 为 sessions 和 windows 取一个好名字非常重要。值得注意的是，panes 似乎不配拥有姓名，但 tmux 会自动为每个 pane 编上序号。如何用好 tmux？首先需要说明 tmux 的操作大量依赖键盘快捷键（类似于 Vim），这对于初学的小伙伴们非常不友好。与学习 Vim 相同，为了记住这些快捷键，只能通过多用多练，慢慢地自然就会熟悉啦。我们先来看一下快捷键中 &lt;prefix&gt; 键的概念： &lt;prefix&gt; 前缀键。顾名思义，我们在按下前缀键之后才能使用对应的快捷键，否则这些快捷键会直接作用在终端而不是 tmux 上。默认的前缀键是 ⌃ + b。可以在配置文件中更改。那么怎么使用呢？举个栗子，在 tmux 中显示切换 session 和 window 的快捷键是 s，那么我们需要先按下 ⌃ + b，然后（放开 ⌃ + b）再单独按下 s，这样就会显示上面那张图的画面啦。一些常用的快捷键这里介绍一些我个人常用的快捷键。使用时请记得在前面加上 &lt;prefix&gt;。 快捷键 说明 s 显示所有的 sessions w 显示所有的 windows（与上面相似，但是会自动展开 windows） z 将当前的 pane 最大化，再按一次则还原 $ 重命名 session , 重命名 window q 显示每个 pane 的编号。在显示期间直接按下对应的数字可以快速切换到该 pane t 显示时钟 c 创建一个新的 window &amp; 关闭（删除）当前的 window % 在右边创建一个新的 pane \" 在下边创建一个新的 pane x 关闭（删除）当前的 pane 更多复杂的快捷键可以看下面的网站： Tmux Cheat Sheet &amp; Quick Reference tmux(1) - OpenBSD manual page配置文件我目前是在使用 GitHub - gpakosz/.tmux，在 GitHub 上应该算是很热门的配置文件了。介绍几点比较重要的改进： 新增了 ⌃ + a 作为 &lt;prefix&gt; 键，因为 a 和 ⌃ 的距离更近，方便使用。（⌃ + b 依然有效） UI 界面的美化，以及添加了电脑开机时间的显示 创建 pane 的快捷键从原来的 % 和 \" 改为 | 和 -，用横线和竖线来分割 pane，更加直观 新增快捷键 m 用于切换鼠标模式，在鼠标模式下可以通过点击来快速切换 pane，通过拖拽改变 pane 的大小，通过滚轮控制终端显示的滚动，选中内容后自动复制等完整的特性可以看 这里参考资料 GitHub - tmux/tmux: tmux source code Tmux Cheat Sheet &amp; Quick Reference" }, { "title": "如何重命名 Git 分支", "url": "/posts/git-rename-branch/", "categories": "技术分享", "tags": "git, branch", "date": "2022-09-23 12:00:00 +0900", "snippet": "工作中经常会遇到分支已经推到远程了之后发现命名有错误，需要修改分支名字的情况。在队友发现之前可以通过下面的步骤赶紧改回来 如果已经创建了 Pull Request 并且有 Review 之后就不建议再改名字啦，因为 GitHub 在你删除分支之后会自动关闭相关的 PR，再开新 PR 的话之前的 Review 找起来会很麻烦。1. 在本地重命名你的分支确保你已经在需要修改名字的分支上$ gi...", "content": "工作中经常会遇到分支已经推到远程了之后发现命名有错误，需要修改分支名字的情况。在队友发现之前可以通过下面的步骤赶紧改回来 如果已经创建了 Pull Request 并且有 Review 之后就不建议再改名字啦，因为 GitHub 在你删除分支之后会自动关闭相关的 PR，再开新 PR 的话之前的 Review 找起来会很麻烦。1. 在本地重命名你的分支确保你已经在需要修改名字的分支上$ git branch -m new-name2. 删除远程分支，并推送重命名后的分支$ git push origin :old-name new-name 关于使用冒号 : 来删除分支，可以看 这篇回答3. 将 upstream 重设为 origin 上新的分支$ git push origin -u new-name设定完成之后就可以正常使用啦。参考资料 Rename a local and remote branch in git – Multiple States Knowledge Base" } ]
