[ { "title": "把 GitHub 的最早提交历史变为 1990 年", "url": "/posts/how-to-make-your-github-history-back-to-1990/", "categories": "技术分享", "tags": "toys, git", "date": "2022-10-09 12:00:00 +0900", "snippet": "最近发现一个有趣的仓库（GitHub - antfu/1990-script），可以把 GitHub 主页显示的提交历史变成 1990 年。看起来就像这个样子：GitHub 主页用法用法很简单，首先准备好 GitHub 用户名和 Access Token，然后执行下面的代码：$ sh -c \"$(curl -fsSL https://raw.github.com/antfu/1990-script/master/index.sh)\"根据提示输入 GitHub 的用户名和 Access Token 就可以了。原理由于 Git 提交时可以使用 GIT_AUTHOR_DATE 和 GIT_COMMITTER_DATE 来手动指定时间（如果不指定则使用当前时间） 关于 GIT_AUTHOR_DATE 和 GIT_COMMITTER_DATE 的区别，可以参考这篇回答脚本中创建了一个名为 ${YEAR} 的仓库并进行了一次提交，提交时间指定为 1990 年 1 月 1 日。把这个仓库推送到 GitHub 之后，GitHub 会分析账户中的提交历史，并且展示到主页上：（2 次贡献分别为创建仓库和 README 的提交）1990 年的提交历史更详细的说明可以看仓库的 README。参考资料 GitHub - antfu/1990-script: Make your GitHub history back to 1990" }, { "title": "用 Storage 来进行前端数据持久化", "url": "/posts/persist-data-to-browser-storage/", "categories": "技术分享", "tags": "data persistence, local storage, session storage", "date": "2022-09-25 17:30:00 +0900", "snippet": "为什么要持久化？想象一个场景，在一个页面中可以设定主题是深色模式或是浅色模式（就和这个博客左侧菜单下方的按钮一样）。如果我们不做持久化，那么即使改变了主题颜色，在刷新页面之后由于数据的丢失，又会变回原来的主题。这对用户来说很不友好。为了防止数据丢失，我们可以把一些数据（或设定）存入硬盘或内存中，下次需要的时候直接读取并使用这些数据，就能够达到保存用户的数据（或设定）的目的啦。怎么持久化？在 Web 应用中持久化一般可以分为前端持久化和后端持久化，前端持久化又有几种方法： Local Storage Session Storage Cookies IndexedDB今天主要讲一下 Local Storage 和 Session Storage。Local Storagewindow.localStorage 中的数据以键值对进行存储，在浏览器的普通模式下，Local Storage 的数据会被存储到硬盘中，直到被主动删除。介绍 4 个常用的 API：// 将 theme 的值设置为 'dark'localStorage.setItem('theme', 'dark');// 获取 theme 的值const theme = localStorage.getItem('theme');// 删除 theme 键localStorage.removeItem('theme');// 删除 storage 中所有的键localStorage.clear();完整的 API 在这里：Storage - Web APIs | MDN值得注意的几个点 建议不要把敏感数据如 Token 放在 Local Storage 中。因为如果网站受到 XSS 攻击可能会导致 Local Storage 中的内容泄露。 Local Storage 中的值只能以 string 类型存储，因此如果需要存对象类型，就要自己负责转换和解析 JSON 字符串。 接上条，null，undefined 等特殊值也会被自动转成 string，因此也需要特殊处理。 在隐私（Private 或者 Incognito）模式下，Local Storage 的数据会在所有隐私模式的窗口关闭后被清除。（具体清除的时机请以各个浏览器的实现为准） 在隐私模式下，Local Storage 的数据共享模式根据不同的浏览器的实现有所不同。已知的有，Chrome 浏览器中所有的 Tab 都会共享同一个 Local Storage。而在 Safari 浏览器中，每个 Tab 的 Local Storage 都是独立的，它们之间的数据无法共享。 可存储的数据大小一般为 5MB 左右。Session Storage与 Local Storage 大致相同，主要区别是 Session Storage 生命周期只存在于一个 Session 中，每当我们打开一个新的 Tab 时，就会创建一个新的 Session，因此不同的 Tab 之间的 Session Storage 无法共享。 当 Tab 被关闭后，Session Storage 中的数据也会被清除。选择合适的 Storage我们可以根据实际需求来选择使用 Local Storage 或是 Session Storage。以设定主题颜色为例，如果使用 Local Storage，那么即使用户关闭浏览器，下次打开时也可以维持上次选择过的主题颜色。而如果使用 Session Storage，那么只能在刷新页面后维持主题颜色，当用户关闭浏览器或是新开一个 Tab 的时候又会变回初始的主题颜色。参考资料 Storage - Web APIs | MDN How Chrome Incognito keeps your browsing private - Google Chrome Help" }, { "title": "介绍几个自动生成 Markdown 链接的工具", "url": "/posts/generate-mark-down-link/", "categories": "技术分享", "tags": "markdown", "date": "2022-09-24 10:30:00 +0900", "snippet": " Markdown 是个好东西。 — Weibin Luo我遇到了什么问题？最近在写 Markdown 的时候需要需要写一些外部的链接，按我的个人习惯一般采用这样的格式来写：[{Page Title}]({Url})举个例子：介绍几个自动生成 Markdown 链接的软件 | Amabel这么写虽然极具观赏性，但是每次都需要自己去 HTML 的代码中找 &lt;title&gt; 标签并取得网页的标题，非常花时间。于是我希望有一款工具，当我输入网页地址时可以自动取得并返回网页的标题，或是直接帮我自动生成 Markdown 格式的链接，等待我去拷贝。更甚至是直接自动帮我拷贝到剪切板，那可就太完美了。 这个功能实现起来并不困难，我在 3 年前曾做过同样的功能，可惜疏于维护。这个我们最后再说。解决思路功能比较简单，那么就说一下思路吧。我们的目标是要取得 HTML 中 &lt;head&gt; 下面 &lt;title&gt; 元素的内容，那么我们只要发起一个 GET 请求来取得网页的内容，之后解析网页的内容并取得相应元素的内容即可。获得 title 之后，我们再把 title 和 url 组合成 Markdown 格式的链接就算基本完成啦。然后有条件的话，还可以加一些自动拷贝，或是让用户自己指定输出格式的功能。 以上只能算是实现了最基本的功能。我们还需要考虑一些边界的情况。比如当返回的内容中含有 Markdown 的特殊的字符的时候，我们需要将其转义（Escape），以此来防止 XSS 攻击以及 Markdown 的格式被破坏。 典型的需要转义的 Markdown 的特殊字符有：\\ ` * _ { } [ ] ( ) # + - . ! 此外，为了防止 XSS 攻击，我们还需要将 &lt;script&gt; 标签中的字符进行转义。所以还要加上 &lt; 和 &gt; 这 2 个字符。几个现成的小工具虽说功能简单，但是把以前的项目捡起来重新维护也需要额外的时间和精力。于是尝试性地谷歌了一波之后，我找到了几个比较有意思且符合我需求的小工具。在这里分享并简单介绍一下实现的原理。 这里主要还是介绍一下本体功能的实现原理，平台（Chrome，VSCode 扩展）相关的一些东西就不写啦。Copy Title &amp; Url as Markdown Style仓库地址：GitHub - zaki-yama/copy-title-and-url-as-markdown这是一款 Chrome 扩展。看名字就知道它是干什么的了！安装扩展之后，打开你要生成链接的网页并点击扩展，大约 0.3 秒之后 Markdown 格式的链接就自动到拷贝你的剪切板了。从结果来说非常符合我的需求，美中不足的是必须自己先访问想要生成链接的网页。代码分析来看看具体是怎么实现的。我们主要关注以下几个文件： src/background.ts src/util.ts src/constant.ts在 background.ts 中，我截取了一部分关键的代码，并添加了一些注释：import { INITIAL_OPTION_VALUES } from \"./constant\";import { escapeBrackets, copyToClipboard } from \"./util\";chrome.tabs.query(queryInfo, function (tabs) { chrome.storage.local.get(INITIAL_OPTION_VALUES, function (options) { const tab = tabs[0]; // 从 Chrome 的当前 tab 中直接获取页面的 title 和 url const title = tab.title || \"\"; const url = tab.url || \"\"; const tabId = tab.id || 0; chrome.scripting.executeScript({ target: { tabId }, func: copyToClipboard, // 执行 copyToClipboard 方法 args: [options[key], title, escapeBrackets(url)], // 将 title 以及转以后的 url 作为方法的参数 }); });这个实现思路可以说是十分巧妙，通过从 Chrome 的 tab 中直接获取页面的 title 和 url，就不需要特地再去发一次 GET 请求来获得相关的信息了。另外我们还看到对 url 使用了 escapeBrackets 方法，这个方法是从 src/util.ts 中引入的。export function escapeBrackets(str: string) { return str .replace(/\\(/g, escape) .replace(/\\)/g, escape) .replace(/\\[/g, escape) .replace(/\\]/g, escape); // 对一些括号字符进行了转义}在 escapeBrackets 方法中，对一部分括号的字符进行了转义。这样可以保证页面的 title 中出现这类字符的时候也可以正常显示 Markdown 格式的链接。但由于没有对所有特殊字符进行转义，所以当 title 中出现其他特殊字符的时候可能会导致页面显示不正常。此外，由于没有转义 &lt; 和 &gt; 这 2 个字符，所以有可能会遭到 XSS 攻击。（这个地方可以考虑改进，提个 PR 什么的）最后再来看看 src/constant.ts：// markdown styleexport const DEFAULT_FORMAT = \"[${title}](${url})\";export const INITIAL_OPTION_VALUES: OptionsType = { format: DEFAULT_FORMAT, optionalFormat1: \"\", optionalFormat2: \"\",};这里主要的功能是用户可以自己定义最终输出的格式，在最终调用 copyToClipboard 时会先转换为定义好的格式在某些情况下应该比较有用。可以在设置页面自定义输出的格式markdown-link-expander仓库地址：GitHub - Skn0tt/markdown-link-expander再来看另一个。这是一个 VSCode 扩展。主要的功能是在 VSCode 中选中 url 后运行扩展，会自动把 url 替换为 Markdown 格式的链接。配合自定义的快捷键使用，可以说是直接起飞。效率起飞代码分析我们主要关注 2 个文件： src/extension.ts src/fetchTitle.ts在 src/extension.ts 中，先是进行了一些 VSCode 扩展的相关的注册，剩下的主要的部分我已经写了一些注释。首先通过 fetchTitle 方法获得页面的 title，然后转换为 Markdown 格式的链接并直接替换选中的文本：import * as vscode from \"vscode\";import { fetchTitle } from \"./fetchTitle\";export function activate(context: vscode.ExtensionContext) { const disposable = vscode.commands.registerCommand( \"markdown-link-expander.expand\", async () =&gt; { // ... const document = editor.document; const selection = editor.selection; let url = document.getText(selection); // ... await vscode.window.withProgress( { location: vscode.ProgressLocation.Notification, title: \"Fetching title ...\" }, async () =&gt; { try { const title = await fetchTitle(url); // 获取 title const markdownLink = `[${title}](${url})`; // 生成 Markdown 格式的链接 editor.edit((editBuilder) =&gt; { editBuilder.replace(selection, markdownLink); // 替换文本 }); } catch (error) { vscode.window.showErrorMessage(\"Failed to fetch title.\"); } } ); } );}再来看 src/fetchTitle.ts：import axios from \"axios\";import * as cheerio from \"cheerio\";export async function fetchTitle(url: string): Promise&lt;string&gt; { const res = await axios.get&lt;string&gt;(url); const $ = cheerio.load(res.data); const title = $(\"title\").text().trim(); return title;}和上面讲过的思路相似，fetchTitle 方法通过 axios 发起一个 GET 请求，然后使用 cherrio 解析网页，并获取 title 的内容。 需要注意的是，这个工具和上面的 Chrome 扩展一样，没有把特殊字符进行转义，所以仍然会存在格式问题和安全隐患。虽然在特殊字符的处理上不是很完美，需要手动调整，但是这个扩展对我来说已经非常够用了。作为一名开源爱好者，这个时候应该提一个改进的 PR，但是由于这个仓库好像已经 1 年多没有维护了，所以也没有提 PR 的打算。说不定将来可以 Fork 下来或者自己写一个 VSCode 扩展。3 年前的项目GitHub - Amabel/md-link是我在 3 年前写的一个小工具。实现的思路还是通过 axios 发送 GET 请求来获取页面的 title。调用它后会返回以下 JSON：{\"title\":\"Amabel's Profile\",\"url\":\"https://amabel.dev\"}当时主要是想着用 axios 来实现，但是考虑到用户端可能没有 Node.js 或是浏览器环境，所以灵机一动直接用 AWS Lambda 和 API Gateway 来做一个 API，这样用户只要通过 cURL 调用 API 就可以很快拿到结果了。 现在仔细一想，既然都可以用 cURL 了，那为什么不直接向网站发 GET 请求然后处理得到的结果呢？(我觉得这个想法非常不错，可以考虑做成一个 brew 的 formula)提几个可以改进的地方，留着以后参考： 用 Serverless 框架来改善部署的设定和步骤 提供网页版和 npm 包等多种版本，方便使用 增加对特殊字符的转义 提供多种输出格式，方便拷贝 README 要认真写！参考资料 GitHub - zaki-yama/copy-title-and-url-as-markdown GitHub - Skn0tt/markdown-link-expander Escaping special characters in markdown | TECH.SAIGONIST.COM" }, { "title": "使用 tmux 来管理终端", "url": "/posts/introduction-to-tmux/", "categories": "技术分享", "tags": "terminal, tmux", "date": "2022-09-23 18:00:00 +0900", "snippet": "我为什么要用 tmux ？作为一名（自称的）全栈工程师，在开发中往往会遇到需要在本地启动很多（5~10 个）服务的情况。如果我们没有办法通过 Docker 来统一管理服务（例如统一启动服务以及日志的集中管理），或是需要经常查看各个服务输出的 log 的情况下，通常只能开多个终端窗口，或是在一个窗口中开启多个标签页，这时终端往往会变成下面这个样子：请注意看顶部，有太多的标签页了这么多的标签页，我们很难快速定位到需要查看 log 的标签页（为每个标签页设定颜色可能有点用，但还是很麻烦）。这时候就轮到我们的主角 tmux 登场了。 关于 tmux 的一些基础的使用方法（比如怎么安装？）不会在本文涉及，如有需要请自行查阅文档。相关链接会放到最下面。本文主要是写一些自己的理解和使用方法，以及一些实用但又经常容易忘记的东西。介绍一下 tmuxtmux 是一款终端复用软件。翻译成人话就是你可以在一个终端内同时管理多个终端，并且可以在多个终端之间自由切换。对于上面的问题，我用 tmux 整理了一下就变成下面这个样子：（由于我使用了）使用 tmux 来管理多个终端看起来是不是高大上了许多？没错，高端程序员的终端就应该是这个样子。在这个界面中，我们可以同时看到多个不同的服务的 log，而且可以随意切换到需要的终端并使其最大化。这样一来，我们调试和写 bug 的速度一定会快很多 &gt; &lt; 由于我使用了配置文件，所以默认的界面看起来和图片上的会不太一样。tmux 中几个重要的概念Session、 window 和 pane 是 tmux 中比较重要的概念，了解这些概念可以帮助我们更好地管理多个终端。 Session 用于管理一个或多个 windows 的集合 Window 一个 window 会占据整个窗口的大小，可以将多个 windows 放入一个 session 中，并且在不同的 windows 之间自由切换。一个 window 内可以包含多个 panes Pane 一个 window 可以分割成多个 panes，一个 pane 相当于一个终端来看一下这张图：tmux 中的 session、window 和 pane上面这张图用绿色和红色标出了 window 和 pane 的概念。并且左下角标出了 session 和 windows 的名字，在这个 session 中有 2 个 windows，名字分别为 「main」 和 「chore」。下面这张图是切换 session 和 window 时的界面。这里显示了我们的电脑上总共有 3 个 sessions，并且显示了 session 下面的 windows 和 panes 的数量和名字。（切换 session 和 window 有很多种方法，这只是其中的一种）切换 session、window 和 pane 的界面掌握了这些概念，我们就可以思考一下如何管理我们的终端了。通常，我会把和某个项目相关的服务都丢进同一个 session 里面，并且把 session 命名为项目的名字。在同一个项目中可能会有很多服务（从而导致有很多 panes），这个时候我会在 session 中创建 2 个 windows，把需要一直监控的服务放到名为「main」的 window 中，把剩余不常用的服务的放到另一个 window 中，这样可以防止主要的 window 中不会有太多的 panes 而导致画面太乱的情况。另外，对于多个项目共用的一些服务，比如 Redis 或是其他数据库，也可以单独新建一个 session，或是直接通过 bg 命令丢到后台运行，取决于你需不需要经常看输出的 log。 为 sessions 和 windows 取一个好名字非常重要。值得注意的是，panes 似乎不配拥有姓名，但 tmux 会自动为每个 pane 编上序号。如何用好 tmux ？首先需要说明 tmux 的操作大量依赖键盘快捷键（类似于 Vim），这对于初学的小伙伴们非常不友好。与学习 Vim 相同，为了记住这些快捷键，只能通过多用多练，慢慢地自然就会熟悉啦。我们先来看一下快捷键中 &lt;prefix&gt; 键的概念： &lt;prefix&gt; 前缀键。顾名思义，我们在按下前缀键之后才能使用对应的快捷键，否则这些快捷键会直接作用在终端而不是 tmux 上。默认的前缀键是 ⌃ + b。可以在配置文件中更改。那么怎么使用呢？举个栗子，在 tmux 中显示切换 session 和 window 的快捷键是 s，那么我们需要先按下 ⌃ + b，然后（放开 ⌃ + b）再单独按下 s，这样就会显示上面那张图的画面啦。一些常用的快捷键这里介绍一些我个人常用的快捷键。使用时请记得在前面加上 &lt;prefix&gt;。 快捷键 说明 s 显示所有的 sessions w 显示所有的 windows（与上面相似，但是会自动展开 windows） z 将当前的 pane 最大化，再按一次则还原 $ 重命名 session , 重命名 window q 显示每个 pane 的编号。在显示期间直接按下对应的数字可以快速切换到该 pane t 显示时钟 c 创建一个新的 window &amp; 关闭（删除）当前的 window % 在右边创建一个新的 pane \" 在下边创建一个新的 pane x 关闭（删除）当前的 pane 更多复杂的快捷键可以看下面的网站： Tmux Cheat Sheet &amp; Quick Reference tmux(1) - OpenBSD manual page配置文件我目前是在使用 GitHub - gpakosz/.tmux，在 GitHub 上应该算是很热门的配置文件了。介绍几点比较重要的改进： 新增了 ⌃ + a 作为 &lt;prefix&gt; 键，因为 a 和 ⌃ 的距离更近，方便使用。（⌃ + b 依然有效） UI 界面的美化，以及添加了电脑开机时间的显示 创建 pane 的快捷键从原来的 % 和 \" 改为 | 和 -，用横线和竖线来分割 pane，更加直观 新增快捷键 m 用于切换鼠标模式，在鼠标模式下可以通过点击来快速切换 pane，通过拖拽改变 pane 的大小，通过滚轮控制终端显示的滚动，选中内容后自动复制等完整的特性可以看 这里参考资料 GitHub - tmux/tmux: tmux source code Tmux Cheat Sheet &amp; Quick Reference" }, { "title": "如何重命名 Git 分支", "url": "/posts/git-rename-branch/", "categories": "技术分享", "tags": "git, branch", "date": "2022-09-23 12:00:00 +0900", "snippet": "工作中经常会遇到分支已经推到远程了之后发现命名有错误，需要修改分支名字的情况。在队友发现之前可以通过下面的步骤赶紧改回来 如果已经创建了 Pull Request 并且有 Review 之后就不建议再改名字啦，因为 GitHub 在你删除分支之后会自动关闭相关的 PR，再开新 PR 的话之前的 Review 找起来会很麻烦。1. 在本地重命名你的分支确保你已经在需要修改名字的分支上$ git branch -m new-name2. 删除远程分支，并推送重命名后的分支$ git push origin :old-name new-name 关于使用冒号 : 来删除分支，可以看 这篇回答3. 将 upstream 重设为 origin 上新的分支$ git push origin -u new-name设定完成之后就可以正常使用啦。参考资料 Rename a local and remote branch in git – Multiple States Knowledge Base" }, { "title": "[置顶] 关于小破客", "url": "/posts/overview/", "categories": "", "tags": "", "date": "2022-09-23 10:00:00 +0900", "snippet": "欢迎来到我的小破客。这里会记录一些工作中遇到的技术上的问题和解决方法，方便总结和以后查找。同时也会分享一些技术性的文章和想法，或是生活中的趣事。主要还是以写给自己看为主，因此文体可能会有些随意。对于一些简单的技术也不会作过多的说明。此外，由于我本人学习计算机相关的技术主要是通过英语和日语，所以在某些专业用语上可能不是非常准确，甚至会直接用英语或是日语代替。请大家谅解！" } ]
