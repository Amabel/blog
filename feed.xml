<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://blog.amabel.dev/</id><title>Amabel</title><subtitle>Amabel的小破客</subtitle> <updated>2022-10-16T18:29:50+09:00</updated> <author> <name>Weibin Luo</name> <uri>https://blog.amabel.dev/</uri> </author><link rel="self" type="application/atom+xml" href="https://blog.amabel.dev/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://blog.amabel.dev/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Weibin Luo </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>关于 JWT 的签名和验证</title><link href="https://blog.amabel.dev/posts/introduction-to-json-web-token/" rel="alternate" type="text/html" title="关于 JWT 的签名和验证" /><published>2022-10-16T10:30:00+09:00</published> <updated>2022-10-16T10:30:00+09:00</updated> <id>https://blog.amabel.dev/posts/introduction-to-json-web-token/</id> <content src="https://blog.amabel.dev/posts/introduction-to-json-web-token/" /> <author> <name>Weibin Luo</name> </author> <category term="技术分享" /> <summary> 介绍 JWT（JSON Web Token）的文章有很多， 这里主要讲一下 JWT 的签名和验证，以及为什么签名是可信的。 由于 JWT 的签名和验证过程比较繁琐，一般情况下不需要自己手动实现。 我们可以通过调用已经封装好的库来轻松验证 JWT 是否有效，以及获取里面的信息。 这里是一些可用的库：JSON Web Token Libraries - jwt.io JWT 签名和验证的过程 首先来看一下 JWT 的结构，下面是一个有效的 JWT： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c ... </summary> </entry> <entry><title>把 GitHub 的最早提交历史变为 1990 年</title><link href="https://blog.amabel.dev/posts/how-to-make-your-github-history-back-to-1990/" rel="alternate" type="text/html" title="把 GitHub 的最早提交历史变为 1990 年" /><published>2022-10-09T12:00:00+09:00</published> <updated>2022-10-09T12:00:00+09:00</updated> <id>https://blog.amabel.dev/posts/how-to-make-your-github-history-back-to-1990/</id> <content src="https://blog.amabel.dev/posts/how-to-make-your-github-history-back-to-1990/" /> <author> <name>Weibin Luo</name> </author> <category term="技术分享" /> <summary> 最近发现一个有趣的仓库（GitHub - antfu/1990-script），可以把 GitHub 主页显示的提交历史变成 1990 年。 看起来就像这个样子： GitHub 主页 用法 用法很简单，首先准备好 GitHub 用户名和 Access Token， 然后执行下面的代码： $ sh -c "$(curl -fsSL https://raw.github.com/antfu/1990-script/master/index.sh)" 根据提示输入 GitHub 的用户名和 Access Token 就可以了。 原理 由于 Git 提交时可以使用 GIT_AUTHOR_DATE 和 GIT_COMMITTER_DATE 来手动指定时间 （如果不指定则使用当前时间） 关于 GIT_AUTHOR_DATE 和 GIT_COMMITTER_DATE ... </summary> </entry> <entry><title>用 Storage 来进行前端数据持久化</title><link href="https://blog.amabel.dev/posts/persist-data-to-browser-storage/" rel="alternate" type="text/html" title="用 Storage 来进行前端数据持久化" /><published>2022-09-25T17:30:00+09:00</published> <updated>2022-09-25T17:30:00+09:00</updated> <id>https://blog.amabel.dev/posts/persist-data-to-browser-storage/</id> <content src="https://blog.amabel.dev/posts/persist-data-to-browser-storage/" /> <author> <name>Weibin Luo</name> </author> <category term="技术分享" /> <summary> 为什么要持久化？ 想象一个场景，在一个页面中可以设定主题是深色模式或是浅色模式（就和这个博客左侧菜单下方的按钮一样）。 如果我们不做持久化，那么即使改变了主题颜色，在刷新页面之后由于数据的丢失，又会变回原来的主题。 这对用户来说很不友好。 为了防止数据丢失，我们可以把一些数据（或设定）存入硬盘或内存中， 下次需要的时候直接读取并使用这些数据，就能够达到保存用户的数据（或设定）的目的啦。 怎么持久化？ 在 Web 应用中持久化一般可以分为前端持久化和后端持久化， 前端持久化又有几种方法： Local Storage Session Storage Cookies IndexedDB 今天主要讲一下 Local Storage 和 Session Storage。 Local Storage window.localStorage 中的数据以键值对进... </summary> </entry> <entry><title>介绍几个自动生成 Markdown 链接的工具</title><link href="https://blog.amabel.dev/posts/generate-mark-down-link/" rel="alternate" type="text/html" title="介绍几个自动生成 Markdown 链接的工具" /><published>2022-09-24T10:30:00+09:00</published> <updated>2022-09-24T10:30:00+09:00</updated> <id>https://blog.amabel.dev/posts/generate-mark-down-link/</id> <content src="https://blog.amabel.dev/posts/generate-mark-down-link/" /> <author> <name>Weibin Luo</name> </author> <category term="技术分享" /> <summary> Markdown 是个好东西。 — Weibin Luo 我遇到了什么问题？ 最近在写 Markdown 的时候需要需要写一些外部的链接， 按我的个人习惯一般采用这样的格式来写： [{Page Title}]({Url}) 举个例子： 介绍几个自动生成 Markdown 链接的软件 | Amabel 这么写虽然极具观赏性，但是每次都需要自己去 HTML 的代码中找 &amp;lt;title&amp;gt; 标签并取得网页的标题，非常花时间。 于是我希望有一款工具，当我输入网页地址时可以自动取得并返回网页的标题， 或是直接帮我自动生成 Markdown 格式的链接，等待我去拷贝。 更甚至是直接自动帮我拷贝到剪切板，那可就太完美了。 这个功能实现起来并不困难，我在 3 年前曾做过同样的功能，可惜疏于维护。这个我们最后再说。 解决思路 功能比较简单，那么就说一... </summary> </entry> <entry><title>使用 tmux 来管理终端</title><link href="https://blog.amabel.dev/posts/introduction-to-tmux/" rel="alternate" type="text/html" title="使用 tmux 来管理终端" /><published>2022-09-23T18:00:00+09:00</published> <updated>2022-09-23T18:00:00+09:00</updated> <id>https://blog.amabel.dev/posts/introduction-to-tmux/</id> <content src="https://blog.amabel.dev/posts/introduction-to-tmux/" /> <author> <name>Weibin Luo</name> </author> <category term="技术分享" /> <summary> 我为什么要用 tmux ？ 作为一名（自称的）全栈工程师，在开发中往往会遇到需要在本地启动很多（5~10 个）服务的情况。 如果我们没有办法通过 Docker 来统一管理服务（例如统一启动服务以及日志的集中管理）， 或是需要经常查看各个服务输出的 log 的情况下， 通常只能开多个终端窗口，或是在一个窗口中开启多个标签页， 这时终端往往会变成下面这个样子： 请注意看顶部，有太多的标签页了 这么多的标签页，我们很难快速定位到需要查看 log 的标签页（为每个标签页设定颜色可能有点用，但还是很麻烦）。 这时候就轮到我们的主角 tmux 登场了。 关于 tmux 的一些基础的使用方法（比如怎么安装？）不会在本文涉及，如有需要请自行查阅文档。相关链接会放到最下面。本文主要是写一些自己的理解和使用方法，以及一些实用但又经常容易忘记的东西。 介绍一下 tmux tmux... </summary> </entry> </feed>
